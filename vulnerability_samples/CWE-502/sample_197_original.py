import dill as pickle
import boto3
import logging
import json
from datetime import datetime
import os
import uuid
import base64
from botocore.exceptions import ClientError

logger = logging.getLogger()
logger.setLevel(logging.INFO)

class MessageProcessingError(Exception):
    pass

class QueueOperationError(Exception):
    pass

def process_message(message):
    try:
        message['processed'] = True
        message['timestamp'] = str(datetime.now())
        message['analysis_result'] = f"Analyzed data: {message.get('data', 'No data')}"
        message['unique_id'] = str(uuid.uuid4())
        return message
    except Exception as e:
        logger.error(f"Error processing message: {str(e)}")
        raise MessageProcessingError(f"Failed to process message: {str(e)}")

def send_to_output_queue(sqs, output_queue_url, message):
    try:
        response = sqs.send_message(
            QueueUrl=output_queue_url,
            MessageBody=json.dumps(message)
        )
        logger.info(f"Message sent to output queue. MessageId: {response['MessageId']}")
    except ClientError as e:
        logger.error(f"Error sending message to output queue: {str(e)}")
        raise QueueOperationError(f"Failed to send message to output queue: {str(e)}")

def delete_from_input_queue(sqs, input_queue_url, receipt_handle):
    try:
        sqs.delete_message(
            QueueUrl=input_queue_url,
            ReceiptHandle=receipt_handle
        )
        logger.info(f"Message deleted from input queue. ReceiptHandle: {receipt_handle}")
    except ClientError as e:
        logger.error(f"Error deleting message from input queue: {str(e)}")
        raise QueueOperationError(f"Failed to delete message from input queue: {str(e)}")

def sanitize_input(input_data):
    if isinstance(input_data, dict):
        return {k: sanitize_input(v) for k, v in input_data.items()}
    elif isinstance(input_data, list):
        return [sanitize_input(i) for i in input_data]
    elif isinstance(input_data, str):
        return input_data.replace('<', '&lt;').replace('>', '&gt;')
    else:
        return input_data

def lambda_handler(event, context):
    sqs = boto3.client('sqs')
    input_queue_url = event.get('input_queue_url') or os.environ.get('INPUT_QUEUE_URL')
    output_queue_url = event.get('output_queue_url') or os.environ.get('OUTPUT_QUEUE_URL')
    
    if not input_queue_url or not output_queue_url:
        raise ValueError("Input and output queue URLs must be provided")

    try:
        response = sqs.receive_message(QueueUrl=input_queue_url, MaxNumberOfMessages=1)
        
        if 'Messages' in response:
            message = response['Messages'][0]
            message_body = message['Body']
            receipt_handle = message['ReceiptHandle']
            
            # Vulnerable line: using pickle.loads for deserialization
            processed_message = pickle.loads(base64.b64decode(message_body))
            
            sanitized_message = sanitize_input(processed_message)
            result = process_message(sanitized_message)
            
            send_to_output_queue(sqs, output_queue_url, result)
            delete_from_input_queue(sqs, input_queue_url, receipt_handle)
            
            return {"status": "success", "message": "Message processed and sent to output queue"}
        else:
            logger.info("No messages in queue")
            return {"status": "info", "message": "No messages in queue"}
    except (MessageProcessingError, QueueOperationError) as e:
        logger.error(f"Error in message processing or queue operation: {str(e)}")
        return {"status": "error", "message": str(e)}
    except Exception as e:
        logger.error(f"Unexpected error in lambda_handler: {str(e)}")
        return {"status": "error", "message": "An unexpected error occurred"}

def cli():
    print("SQS Message Processor CLI")
    input_queue_url = input("Enter input queue URL: ")
    output_queue_url = input("Enter output queue URL: ")
    
    event = {
        "input_queue_url": input_queue_url,
        "output_queue_url": output_queue_url
    }
    
    result = lambda_handler(event, None)
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    cli()

def test_lambda_handler():
    test_event = {
        "input_queue_url": "https://sqs.us-east-1.amazonaws.com/123456789012/test-input-queue",
        "output_queue_url": "https://sqs.us-east-1.amazonaws.com/123456789012/test-output-queue"
    }
    
    # Mock SQS client
    class MockSQS:
        def receive_message(self, **kwargs):
            return {
                "Messages": [{
                    "Body": base64.b64encode(pickle.dumps({"data": "test data"})),
                    "ReceiptHandle": "test-receipt-handle"
                }]
            }
        
        def send_message(self, **kwargs):
            return {"MessageId": "test-message-id"}
        
        def delete_message(self, **kwargs):
            pass
    
    boto3.client = lambda service: MockSQS()
    
    result = lambda_handler(test_event, None)
    assert result["status"] == "success", f"Test failed: {result}"
    print("Test passed successfully")

test_lambda_handler()