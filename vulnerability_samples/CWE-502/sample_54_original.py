from sanic import Sanic, response
import shelve
import uuid
import logging
from functools import wraps
import json
import os

app = Sanic("DataReportingApp")
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class AuthenticationError(Exception):
    pass

class ReportNotFoundError(Exception):
    pass

def authenticate(func):
    @wraps(func)
    async def wrapper(request, *args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            logging.warning(f"Authentication attempt without token from {request.ip}")
            return response.json({'error': 'Authentication required'}, status=401)
        try:
            with shelve.open('users.db') as users_db:
                if token not in users_db:
                    raise AuthenticationError("Invalid token")
            logging.info(f"Successful authentication for token {token[:8]}...")
            return await func(request, *args, **kwargs)
        except AuthenticationError as e:
            logging.error(f"Authentication failed: {str(e)}")
            return response.json({'error': str(e)}, status=401)
    return wrapper

@app.route('/login', methods=['POST'])
async def login(request):
    username = request.json.get('username')
    password = request.json.get('password')
    if not username or not password:
        return response.json({'error': 'Username and password are required'}, status=400)
    try:
        with shelve.open('users.db') as users_db:
            if username in users_db and users_db[username] == password:
                token = str(uuid.uuid4())
                users_db[token] = username
                logging.info(f"User {username} logged in successfully")
                return response.json({'token': token})
        raise AuthenticationError("Invalid credentials")
    except AuthenticationError as e:
        logging.warning(f"Login attempt failed for user {username}")
        return response.json({'error': str(e)}, status=401)

@app.route('/report/<report_id>')
@authenticate
async def get_report(request, report_id):
    try:
        with shelve.open('reports.db') as db:
            report = db.get(report_id)
            if not report:
                raise ReportNotFoundError(f"Report with ID {report_id} not found")
        logging.info(f"Report {report_id} retrieved successfully")
        return response.json(report)
    except ReportNotFoundError as e:
        logging.warning(str(e))
        return response.json({'error': str(e)}, status=404)

@app.route('/report', methods=['POST'])
@authenticate
async def add_report(request):
    report_data = request.json
    if not report_data:
        return response.json({'error': 'Report data is required'}, status=400)
    report_id = str(uuid.uuid4())
    try:
        with shelve.open('reports.db') as db:
            db[report_id] = report_data
        logging.info(f"New report added with ID {report_id}")
        return response.json({'report_id': report_id})
    except Exception as e:
        logging.error(f"Error adding report: {str(e)}")
        return response.json({'error': 'Failed to add report'}, status=500)

@app.route('/reports')
@authenticate
async def list_reports(request):
    try:
        with shelve.open('reports.db') as db:
            report_ids = list(db.keys())
        logging.info(f"Listed {len(report_ids)} reports")
        return response.json({'report_ids': report_ids})
    except Exception as e:
        logging.error(f"Error listing reports: {str(e)}")
        return response.json({'error': 'Failed to list reports'}, status=500)

@app.route('/report/<report_id>', methods=['PUT'])
@authenticate
async def update_report(request, report_id):
    report_data = request.json
    if not report_data:
        return response.json({'error': 'Report data is required'}, status=400)
    try:
        with shelve.open('reports.db') as db:
            if report_id not in db:
                raise ReportNotFoundError(f"Report with ID {report_id} not found")
            db[report_id] = report_data
        logging.info(f"Report {report_id} updated successfully")
        return response.json({'message': 'Report updated successfully'})
    except ReportNotFoundError as e:
        logging.warning(str(e))
        return response.json({'error': str(e)}, status=404)
    except Exception as e:
        logging.error(f"Error updating report: {str(e)}")
        return response.json({'error': 'Failed to update report'}, status=500)

@app.route('/report/<report_id>', methods=['DELETE'])
@authenticate
async def delete_report(request, report_id):
    try:
        with shelve.open('reports.db') as db:
            if report_id not in db:
                raise ReportNotFoundError(f"Report with ID {report_id} not found")
            del db[report_id]
        logging.info(f"Report {report_id} deleted successfully")
        return response.json({'message': 'Report deleted successfully'})
    except ReportNotFoundError as e:
        logging.warning(str(e))
        return response.json({'error': str(e)}, status=404)
    except Exception as e:
        logging.error(f"Error deleting report: {str(e)}")
        return response.json({'error': 'Failed to delete report'}, status=500)

@app.route('/backup', methods=['POST'])
@authenticate
async def backup_database(request):
    try:
        with shelve.open('reports.db') as db:
            backup_data = dict(db)
        with open('backup.json', 'w') as f:
            json.dump(backup_data, f)
        logging.info("Database backup created successfully")
        return response.json({'message': 'Backup created successfully'})
    except Exception as e:
        logging.error(f"Error creating backup: {str(e)}")
        return response.json({'error': 'Failed to create backup'}, status=500)

@app.route('/restore', methods=['POST'])
@authenticate
async def restore_database(request):
    try:
        if not os.path.exists('backup.json'):
            return response.json({'error': 'No backup file found'}, status=404)
        with open('backup.json', 'r') as f:
            backup_data = json.load(f)
        with shelve.open('reports.db') as db:
            db.clear()
            for key, value in backup_data.items():
                db[key] = value
        logging.info("Database restored successfully")
        return response.json({'message': 'Database restored successfully'})
    except Exception as e:
        logging.error(f"Error restoring database: {str(e)}")
        return response.json({'error': 'Failed to restore database'}, status=500)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)