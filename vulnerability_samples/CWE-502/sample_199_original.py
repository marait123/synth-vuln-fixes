import ruamel.yaml
import os
import socket
import threading
import logging
import sys
import argparse
from typing import Dict, Any, Tuple

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ConfigError(Exception):
    pass

class ServerError(Exception):
    pass

def process_server_config(config_path: str) -> Dict[str, Any]:
    yaml = ruamel.yaml.YAML(typ='unsafe')
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Config file not found: {config_path}")
    try:
        with open(config_path, 'r') as file:
            config = yaml.load(file)
        return config
    except ruamel.yaml.YAMLError as e:
        raise ConfigError(f"Error parsing YAML file {config_path}: {str(e)}")

def process_multiple_configs(config_directory: str) -> Dict[str, Dict[str, Any]]:
    configs = {}
    if not os.path.isdir(config_directory):
        raise NotADirectoryError(f"Config directory not found: {config_directory}")
    for filename in os.listdir(config_directory):
        if filename.endswith('.yaml'):
            file_path = os.path.join(config_directory, filename)
            try:
                configs[filename] = process_server_config(file_path)
            except (FileNotFoundError, ConfigError) as e:
                logger.error(f"Error processing {filename}: {str(e)}")
    return configs

def apply_server_settings(config: Dict[str, Any]) -> Tuple[str, int, int, int]:
    server_settings = config.get('server', {})
    host = server_settings.get('host', 'localhost')
    port = server_settings.get('port', 8080)
    max_connections = server_settings.get('max_connections', 5)
    timeout = server_settings.get('timeout', 60)
    return host, port, max_connections, timeout

def handle_client(client_socket: socket.socket, address: Tuple[str, int], timeout: int):
    logger.info(f"New connection from {address}")
    client_socket.settimeout(timeout)
    try:
        while True:
            data = client_socket.recv(1024)
            if not data:
                break
            client_socket.send(data)
    except socket.timeout:
        logger.warning(f"Connection from {address} timed out")
    except Exception as e:
        logger.error(f"Error handling client {address}: {str(e)}")
    finally:
        client_socket.close()
        logger.info(f"Connection closed for {address}")

def start_server(host: str, port: int, max_connections: int, timeout: int):
    try:
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind((host, port))
        server_socket.listen(max_connections)
        logger.info(f"Server listening on {host}:{port}")

        while True:
            client_socket, address = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(client_socket, address, timeout))
            client_thread.start()
    except Exception as e:
        raise ServerError(f"Error starting server: {str(e)}")
    finally:
        server_socket.close()

def validate_config(config: Dict[str, Any]) -> bool:
    required_keys = ['server']
    for key in required_keys:
        if key not in config:
            logger.error(f"Missing required key in config: {key}")
            return False
    return True

def main():
    parser = argparse.ArgumentParser(description="Server Configuration Processor")
    parser.add_argument("-c", "--config", default="config", help="Path to config directory")
    args = parser.parse_args()

    try:
        configs = process_multiple_configs(args.config)
        if not configs:
            logger.error("No valid configurations found.")
            sys.exit(1)

        for filename, config in configs.items():
            logger.info(f"Processing config: {filename}")
            if not validate_config(config):
                logger.error(f"Invalid configuration in {filename}")
                continue

            host, port, max_connections, timeout = apply_server_settings(config)
            try:
                start_server(host, port, max_connections, timeout)
            except ServerError as e:
                logger.error(str(e))
    except Exception as e:
        logger.critical(f"Unhandled exception: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()