import logging
import os
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
import jwt
from typing import List, Dict

app = FastAPI()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Secure secret key
SECRET_KEY = os.getenv("SECRET_KEY")
if not SECRET_KEY:
    raise RuntimeError("SECRET_KEY environment variable not set")

class User(BaseModel):
    username: str
    password: str

class UserInDB(User):
    id: int

# In-memory user database
users_db: Dict[str, UserInDB] = {}
user_id_counter = 1

def get_current_user(token: str = Depends()):
    try:
        payload = jwt.decode(token, key=SECRET_KEY, algorithms=["HS256"])
        username = payload.get("username")
        if username not in users_db:
            raise HTTPException(status_code=401, detail="User not found")
        return users_db[username]
    except jwt.PyJWTError:
        logger.warning(f"Invalid token: {token}")
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")

@app.post("/register")
def register(user: User):
    global user_id_counter
    if user.username in users_db:
        raise HTTPException(status_code=400, detail="Username already registered")
    new_user = UserInDB(**user.dict(), id=user_id_counter)
    users_db[user.username] = new_user
    user_id_counter += 1
    logger.info(f"New user registered: {user.username}")
    return {"message": "User registered successfully"}

@app.post("/login")
def login(user: User):
    if user.username not in users_db or users_db[user.username].password != user.password:
        logger.warning(f"Failed login attempt for user: {user.username}")
        raise HTTPException(status_code=401, detail="Invalid username or password")
    token = jwt.encode({"username": user.username}, key=SECRET_KEY, algorithm="HS256")
    logger.info(f"User logged in: {user.username}")
    return {"token": token}

@app.get("/protected")
def protected_route(current_user: UserInDB = Depends(get_current_user)):
    return {"message": f"Hello, {current_user.username}! This is a protected route."}

@app.get("/users", response_model=List[str])
def get_all_users(current_user: UserInDB = Depends(get_current_user)):
    return list(users_db.keys())

@app.get("/user/{username}")
def get_user(username: str, current_user: UserInDB = Depends(get_current_user)):
    if username not in users_db:
        raise HTTPException(status_code=404, detail="User not found")
    return users_db[username]