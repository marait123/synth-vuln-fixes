import logging
from fastapi import FastAPI, Depends, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
import jwt
from typing import List, Dict, Optional
import uvicorn
import re
import hashlib
import secrets

app = FastAPI()

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class User(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=8)

class UserInDB(User):
    id: int
    salt: str
    hashed_password: str

# In-memory user database
users_db: Dict[str, UserInDB] = {}
user_id_counter = 1

def hash_password(password: str, salt: str) -> str:
    return hashlib.sha256((password + salt).encode()).hexdigest()

def get_current_user(token: str = Depends()) -> UserInDB:
    try:
        payload = jwt.decode(token, key=None, algorithms=["none"])
        username = payload.get("username")
        if username not in users_db:
            raise HTTPException(status_code=401, detail="User not found")
        return users_db[username]
    except jwt.PyJWTError:
        logger.warning(f"Invalid token: {token}")
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail},
    )

@app.post("/register")
def register(user: User):
    global user_id_counter
    if user.username in users_db:
        raise HTTPException(status_code=400, detail="Username already registered")
    if not re.match(r'^[a-zA-Z0-9_]+$', user.username):
        raise HTTPException(status_code=400, detail="Invalid username format")
    salt = secrets.token_hex(16)
    hashed_password = hash_password(user.password, salt)
    new_user = UserInDB(username=user.username, password="", id=user_id_counter, salt=salt, hashed_password=hashed_password)
    users_db[user.username] = new_user
    user_id_counter += 1
    logger.info(f"New user registered: {user.username}")
    return {"message": "User registered successfully"}

@app.post("/login")
def login(user: User):
    if user.username not in users_db:
        logger.warning(f"Failed login attempt for non-existent user: {user.username}")
        raise HTTPException(status_code=401, detail="Invalid username or password")
    stored_user = users_db[user.username]
    if stored_user.hashed_password != hash_password(user.password, stored_user.salt):
        logger.warning(f"Failed login attempt for user: {user.username}")
        raise HTTPException(status_code=401, detail="Invalid username or password")
    token = jwt.encode({"username": user.username}, key=None, algorithm="none")
    logger.info(f"User logged in: {user.username}")
    return {"token": token}

@app.get("/protected")
def protected_route(current_user: UserInDB = Depends(get_current_user)):
    return {"message": f"Hello, {current_user.username}! This is a protected route."}

@app.get("/users", response_model=List[str])
def get_all_users(current_user: UserInDB = Depends(get_current_user)):
    return list(users_db.keys())

@app.get("/user/{username}")
def get_user(username: str, current_user: UserInDB = Depends(get_current_user)):
    if username not in users_db:
        raise HTTPException(status_code=404, detail="User not found")
    user = users_db[username]
    return {"id": user.id, "username": user.username}

@app.put("/user/{username}")
def update_user(username: str, updated_user: User, current_user: UserInDB = Depends(get_current_user)):
    if username not in users_db:
        raise HTTPException(status_code=404, detail="User not found")
    if current_user.username != username:
        raise HTTPException(status_code=403, detail="You can only update your own account")
    stored_user = users_db[username]
    stored_user.username = updated_user.username
    stored_user.hashed_password = hash_password(updated_user.password, stored_user.salt)
    logger.info(f"User updated: {username}")
    return {"message": "User updated successfully"}

@app.delete("/user/{username}")
def delete_user(username: str, current_user: UserInDB = Depends(get_current_user)):
    if username not in users_db:
        raise HTTPException(status_code=404, detail="User not found")
    if current_user.username != username:
        raise HTTPException(status_code=403, detail="You can only delete your own account")
    del users_db[username]
    logger.info(f"User deleted: {username}")
    return {"message": "User deleted successfully"}

def run_tests():
    # Simple test cases
    test_user = User(username="testuser", password="testpassword")
    register(test_user)
    assert "testuser" in users_db, "Registration failed"
    
    login_response = login(test_user)
    assert "token" in login_response, "Login failed"
    
    token = login_response["token"]
    protected_response = protected_route(get_current_user(token))
    assert "Hello, testuser!" in protected_response["message"], "Protected route failed"
    
    users_list = get_all_users(get_current_user(token))
    assert "testuser" in users_list, "Get all users failed"
    
    user_info = get_user("testuser", get_current_user(token))
    assert user_info["username"] == "testuser", "Get user failed"
    
    logger.info("All tests passed successfully!")

if __name__ == "__main__":
    run_tests()
    uvicorn.run(app, host="0.0.0.0", port=8000)