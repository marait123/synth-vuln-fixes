import os
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import logging
import base64
import json
import argparse

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class EncryptionError(Exception):
    pass

class DecryptionError(Exception):
    pass

class FileOperationError(Exception):
    pass

def generate_key():
    return get_random_bytes(32)

def encrypt_file(filename, key):
    try:
        cipher = AES.new(key, AES.MODE_CBC)
        with open(filename, 'rb') as f:
            plaintext = f.read()
        padded_data = pad(plaintext, AES.block_size)
        ciphertext = cipher.encrypt(padded_data)
        iv = cipher.iv
        return iv + ciphertext
    except Exception as e:
        logger.error(f"Encryption error: {str(e)}")
        raise EncryptionError(f"Failed to encrypt file: {str(e)}")

def decrypt_file(encrypted_data, key):
    try:
        iv = encrypted_data[:16]
        ciphertext = encrypted_data[16:]
        cipher = AES.new(key, AES.MODE_CBC, iv)
        padded_plaintext = cipher.decrypt(ciphertext)
        plaintext = unpad(padded_plaintext, AES.block_size)
        return plaintext
    except Exception as e:
        logger.error(f"Decryption error: {str(e)}")
        raise DecryptionError(f"Failed to decrypt data: {str(e)}")

def save_encrypted_file(filename, encrypted_data):
    try:
        with open(filename + '.encrypted', 'wb') as f:
            f.write(encrypted_data)
        logger.info(f"Encrypted file saved as {filename}.encrypted")
    except Exception as e:
        logger.error(f"Error saving encrypted file: {str(e)}")
        raise FileOperationError(f"Failed to save encrypted file: {str(e)}")

def load_encrypted_file(filename):
    try:
        with open(filename, 'rb') as f:
            return f.read()
    except Exception as e:
        logger.error(f"Error loading encrypted file: {str(e)}")
        raise FileOperationError(f"Failed to load encrypted file: {str(e)}")

def save_key(key, filename):
    try:
        with open(filename, 'wb') as f:
            f.write(key)
        logger.info(f"Key saved to {filename}")
    except Exception as e:
        logger.error(f"Error saving key: {str(e)}")
        raise FileOperationError(f"Failed to save key: {str(e)}")

def load_key(filename):
    try:
        with open(filename, 'rb') as f:
            return f.read()
    except Exception as e:
        logger.error(f"Error loading key: {str(e)}")
        raise FileOperationError(f"Failed to load key: {str(e)}")

def encrypt_and_save(input_file, output_file, key_file):
    key = generate_key()
    save_key(key, key_file)
    encrypted_data = encrypt_file(input_file, key)
    save_encrypted_file(output_file, encrypted_data)

def load_and_decrypt(input_file, output_file, key_file):
    key = load_key(key_file)
    encrypted_data = load_encrypted_file(input_file)
    decrypted_data = decrypt_file(encrypted_data, key)
    with open(output_file, 'wb') as f:
        f.write(decrypted_data)
    logger.info(f"Decrypted data saved to {output_file}")

def main():
    parser = argparse.ArgumentParser(description="File encryption and decryption tool")
    parser.add_argument('action', choices=['encrypt', 'decrypt'], help="Action to perform")
    parser.add_argument('input_file', help="Input file path")
    parser.add_argument('output_file', help="Output file path")
    parser.add_argument('key_file', help="Key file path")
    args = parser.parse_args()

    try:
        if args.action == 'encrypt':
            encrypt_and_save(args.input_file, args.output_file, args.key_file)
        elif args.action == 'decrypt':
            load_and_decrypt(args.input_file, args.output_file, args.key_file)
    except (EncryptionError, DecryptionError, FileOperationError) as e:
        logger.error(f"Operation failed: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")

if __name__ == "__main__":
    main()