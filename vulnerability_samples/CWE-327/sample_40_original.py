from fastapi import FastAPI, Depends, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel, EmailStr, Field
import jwt
from typing import Dict, List, Optional
import logging
import bcrypt
import re
import uuid

app = FastAPI()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class User(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    full_name: str = Field(..., min_length=1, max_length=100)

class UserInDB(User):
    password: str = Field(..., min_length=8)
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))

users_db: Dict[str, UserInDB] = {}

def get_password_hash(password: str) -> str:
    return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return bcrypt.checkpw(plain_password.encode(), hashed_password.encode())

def get_current_user(token: str = Depends()):
    try:
        payload = jwt.decode(token, key=None, algorithms=["none"])
        username = payload.get("username")
        if username not in users_db:
            raise HTTPException(status_code=401, detail="User not found")
        return users_db[username]
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    return JSONResponse(status_code=500, content={"detail": "Internal server error"})

@app.post("/register")
def register(user: UserInDB):
    if user.username in users_db:
        raise HTTPException(status_code=400, detail="Username already registered")
    if not re.match(r"^[a-zA-Z0-9_]+$", user.username):
        raise HTTPException(status_code=400, detail="Invalid username format")
    user.password = get_password_hash(user.password)
    users_db[user.username] = user
    logger.info(f"User registered: {user.username}")
    return {"message": "User registered successfully"}

@app.post("/login")
def login(username: str, password: str):
    if username not in users_db or not verify_password(password, users_db[username].password):
        raise HTTPException(status_code=401, detail="Invalid username or password")
    token = jwt.encode({"username": username}, key=None, algorithm="none")
    logger.info(f"User logged in: {username}")
    return {"token": token}

@app.get("/users/me", response_model=User)
def read_users_me(current_user: UserInDB = Depends(get_current_user)):
    return current_user

@app.get("/users", response_model=List[User])
def read_users(current_user: UserInDB = Depends(get_current_user)):
    return list(users_db.values())

@app.put("/users/me", response_model=User)
def update_user(user_update: User, current_user: UserInDB = Depends(get_current_user)):
    current_user.email = user_update.email
    current_user.full_name = user_update.full_name
    users_db[current_user.username] = current_user
    logger.info(f"User updated: {current_user.username}")
    return current_user

@app.delete("/users/me")
def delete_user(current_user: UserInDB = Depends(get_current_user)):
    del users_db[current_user.username]
    logger.info(f"User deleted: {current_user.username}")
    return {"message": "User deleted successfully"}

@app.get("/users/{username}", response_model=User)
def read_user(username: str, current_user: UserInDB = Depends(get_current_user)):
    if username not in users_db:
        raise HTTPException(status_code=404, detail="User not found")
    return users_db[username]

@app.put("/users/{username}/password")
def change_password(username: str, old_password: str, new_password: str, current_user: UserInDB = Depends(get_current_user)):
    if username != current_user.username:
        raise HTTPException(status_code=403, detail="Not authorized to change this user's password")
    if not verify_password(old_password, current_user.password):
        raise HTTPException(status_code=401, detail="Invalid old password")
    current_user.password = get_password_hash(new_password)
    users_db[username] = current_user
    logger.info(f"Password changed for user: {username}")
    return {"message": "Password changed successfully"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

# Test cases
def test_register():
    user = UserInDB(username="testuser", email="test@example.com", full_name="Test User", password="password123")
    response = register(user)
    assert response == {"message": "User registered successfully"}
    assert "testuser" in users_db

def test_login():
    response = login("testuser", "password123")
    assert "token" in response

def test_read_users_me():
    token = login("testuser", "password123")["token"]
    current_user = get_current_user(token)
    response = read_users_me(current_user)
    assert response.username == "testuser"

def run_tests():
    test_register()
    test_login()
    test_read_users_me()
    print("All tests passed!")

# Uncomment to run tests
# run_tests()