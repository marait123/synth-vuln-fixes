# Django settings.py
import os

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
SECRET_KEY = 'your-secret-key-here'
DEBUG = True
ALLOWED_HOSTS = ['*']

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'chat_app',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'chat_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'chat_project.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True

STATIC_URL = '/static/'

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'file': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'debug.log'),
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file'],
            'level': 'DEBUG',
            'propagate': True,
        },
    },
}

# Django models.py
from django.db import models
from django.contrib.auth.models import User

class ChatMessage(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    message = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.username}: {self.message[:50]}"

# Django views.py
from django.http import HttpResponse, JsonResponse
from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth import authenticate, login, logout
from django.core.exceptions import ValidationError
from .models import ChatMessage
import socket
import json
import logging

logger = logging.getLogger(__name__)

def start_socket():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind(('0.0.0.0', 1337))
        s.listen(1)
        logger.info("Socket started on 0.0.0.0:1337")
        return s
    except Exception as e:
        logger.error(f"Failed to start socket: {str(e)}")
        return None

socket_server = start_socket()

@login_required
def index(request):
    return HttpResponse("Welcome to the Chat App!")

@csrf_exempt
def user_login(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            username = data.get('username')
            password = data.get('password')
            if not username or not password:
                raise ValidationError("Username and password are required")
            user = authenticate(request, username=username, password=password)
            if user is not None:
                login(request, user)
                logger.info(f"User {username} logged in successfully")
                return JsonResponse({"status": "success"})
            else:
                logger.warning(f"Failed login attempt for user {username}")
                return JsonResponse({"status": "error", "message": "Invalid credentials"}, status=401)
        except json.JSONDecodeError:
            logger.error("Invalid JSON in login request")
            return JsonResponse({"status": "error", "message": "Invalid JSON"}, status=400)
        except ValidationError as ve:
            logger.error(f"Validation error in login: {str(ve)}")
            return JsonResponse({"status": "error", "message": str(ve)}, status=400)
        except Exception as e:
            logger.error(f"Unexpected error in login: {str(e)}")
            return JsonResponse({"status": "error", "message": "An unexpected error occurred"}, status=500)
    return JsonResponse({"status": "error", "message": "Method not allowed"}, status=405)

@login_required
def user_logout(request):
    logout(request)
    logger.info(f"User {request.user.username} logged out")
    return JsonResponse({"status": "success"})

@login_required
@csrf_exempt
def send_message(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            message = data.get('message')
            if not message:
                raise ValidationError("Message cannot be empty")
            ChatMessage.objects.create(user=request.user, message=message)
            logger.info(f"Message sent by user {request.user.username}")
            return JsonResponse({"status": "success"})
        except json.JSONDecodeError:
            logger.error("Invalid JSON in send_message request")
            return JsonResponse({"status": "error", "message": "Invalid JSON"}, status=400)
        except ValidationError as ve:
            logger.error(f"Validation error in send_message: {str(ve)}")
            return JsonResponse({"status": "error", "message": str(ve)}, status=400)
        except Exception as e:
            logger.error(f"Unexpected error in send_message: {str(e)}")
            return JsonResponse({"status": "error", "message": "An unexpected error occurred"}, status=500)
    return JsonResponse({"status": "error", "message": "Method not allowed"}, status=405)

@login_required
def get_messages(request):
    try:
        messages = ChatMessage.objects.all().order_by('-timestamp')[:50]
        data = [{"user": msg.user.username, "message": msg.message, "timestamp": msg.timestamp.isoformat()} for msg in messages]
        return JsonResponse(data, safe=False)
    except Exception as e:
        logger.error(f"Error fetching messages: {str(e)}")
        return JsonResponse({"status": "error", "message": "Failed to fetch messages"}, status=500)

# Django urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('login/', views.user_login, name='login'),
    path('logout/', views.user_logout, name='logout'),
    path('send_message/', views.send_message, name='send_message'),
    path('get_messages/', views.get_messages, name='get_messages'),
]

# Test cases
import unittest
from django.test import Client
from django.contrib.auth.models import User

class ChatAppTestCase(unittest.TestCase):
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user(username='testuser', password='testpass')

    def test_login(self):
        response = self.client.post('/login/', json.dumps({'username': 'testuser', 'password': 'testpass'}), content_type='application/json')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(json.loads(response.content), {"status": "success"})

    def test_send_message(self):
        self.client.login(username='testuser', password='testpass')
        response = self.client.post('/send_message/', json.dumps({'message': 'Test message'}), content_type='application/json')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(json.loads(response.content), {"status": "success"})

    def test_get_messages(self):
        self.client.login(username='testuser', password='testpass')
        response = self.client.get('/get_messages/')
        self.assertEqual(response.status_code, 200)
        self.assertIsInstance(json.loads(response.content), list)

if __name__ == '__main__':
    unittest.main()