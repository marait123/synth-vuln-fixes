from flask import Flask, request, render_template, redirect, url_for, session, jsonify
from sqlalchemy import create_engine, text
from werkzeug.security import generate_password_hash, check_password_hash
import os
import logging
from functools import wraps

app = Flask(__name__)
app.secret_key = os.urandom(24)
engine = create_engine("sqlite:///example.db")

logging.basicConfig(filename='app.log', level=logging.INFO)

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session or not session.get('is_admin'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        try:
            with engine.connect() as conn:
                result = conn.execute(text("SELECT * FROM users WHERE username = :username"), {"username": username}).fetchone()
                if result and check_password_hash(result['password'], password):
                    session['user_id'] = result['id']
                    session['is_admin'] = result['is_admin']
                    logging.info(f"User {username} logged in successfully")
                    return redirect(url_for('dashboard'))
                else:
                    logging.warning(f"Failed login attempt for user {username}")
        except Exception as e:
            logging.error(f"Error during login: {str(e)}")
    return render_template('login.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        hashed_password = generate_password_hash(password)
        try:
            with engine.connect() as conn:
                conn.execute(text("INSERT INTO users (username, password, is_admin) VALUES (:username, :password, :is_admin)"),
                             {"username": username, "password": hashed_password, "is_admin": False})
                logging.info(f"New user registered: {username}")
            return redirect(url_for('login'))
        except Exception as e:
            logging.error(f"Error during registration: {str(e)}")
    return render_template('register.html')

@app.route('/dashboard')
@login_required
def dashboard():
    return render_template('dashboard.html')

@app.route('/search')
def search():
    query = request.args.get('query', '')
    sql = "SELECT * FROM products WHERE name LIKE '%{}%'".format(query)
    try:
        with engine.connect() as conn:
            results = conn.execute(text(sql)).fetchall()
        return render_template('search_results.html', results=results)
    except Exception as e:
        logging.error(f"Error during search: {str(e)}")
        return "An error occurred", 500

@app.route('/admin/products')
@admin_required
def admin_products():
    try:
        with engine.connect() as conn:
            products = conn.execute(text("SELECT * FROM products")).fetchall()
        return render_template('admin_products.html', products=products)
    except Exception as e:
        logging.error(f"Error fetching products: {str(e)}")
        return "An error occurred", 500

@app.route('/admin/products/add', methods=['GET', 'POST'])
@admin_required
def add_product():
    if request.method == 'POST':
        name = request.form['name']
        price = request.form['price']
        try:
            with engine.connect() as conn:
                conn.execute(text("INSERT INTO products (name, price) VALUES (:name, :price)"),
                             {"name": name, "price": price})
            logging.info(f"New product added: {name}")
            return redirect(url_for('admin_products'))
        except Exception as e:
            logging.error(f"Error adding product: {str(e)}")
    return render_template('add_product.html')

@app.route('/admin/products/edit/<int:product_id>', methods=['GET', 'POST'])
@admin_required
def edit_product(product_id):
    try:
        with engine.connect() as conn:
            if request.method == 'POST':
                name = request.form['name']
                price = request.form['price']
                conn.execute(text("UPDATE products SET name = :name, price = :price WHERE id = :id"),
                             {"name": name, "price": price, "id": product_id})
                logging.info(f"Product updated: ID {product_id}")
                return redirect(url_for('admin_products'))
            product = conn.execute(text("SELECT * FROM products WHERE id = :id"), {"id": product_id}).fetchone()
        return render_template('edit_product.html', product=product)
    except Exception as e:
        logging.error(f"Error editing product: {str(e)}")
        return "An error occurred", 500

@app.route('/admin/products/delete/<int:product_id>')
@admin_required
def delete_product(product_id):
    try:
        with engine.connect() as conn:
            conn.execute(text("DELETE FROM products WHERE id = :id"), {"id": product_id})
        logging.info(f"Product deleted: ID {product_id}")
        return redirect(url_for('admin_products'))
    except Exception as e:
        logging.error(f"Error deleting product: {str(e)}")
        return "An error occurred", 500

@app.route('/api/products', methods=['GET'])
def api_get_products():
    try:
        with engine.connect() as conn:
            products = conn.execute(text("SELECT * FROM products")).fetchall()
        return jsonify([dict(p) for p in products])
    except Exception as e:
        logging.error(f"API error: {str(e)}")
        return jsonify({"error": "An error occurred"}), 500

def init_db():
    with engine.connect() as conn:
        conn.execute(text("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                password TEXT NOT NULL,
                is_admin BOOLEAN NOT NULL DEFAULT 0
            )
        """))
        conn.execute(text("""
            CREATE TABLE IF NOT EXISTS products (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                price REAL NOT NULL
            )
        """))
    logging.info("Database initialized")

if __name__ == '__main__':
    init_db()
    app.run(debug=True)