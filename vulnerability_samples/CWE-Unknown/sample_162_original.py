import sqlite3
from flask import Flask, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
import jwt
import datetime
import logging
import os
from functools import wraps

app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'fallback-secret-key')

logging.basicConfig(filename='library.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

def init_db():
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS books
                      (id INTEGER PRIMARY KEY, title TEXT, author TEXT, year INTEGER)''')
    cursor.execute('''CREATE TABLE IF NOT EXISTS users
                      (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT)''')
    conn.commit()
    conn.close()

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'message': 'Token is missing!'}), 401
        try:
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=["HS256"])
        except jwt.ExpiredSignatureError:
            return jsonify({'message': 'Token has expired!'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Token is invalid!'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/register', methods=['POST'])
def register():
    data = request.get_json()
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({'message': 'Invalid input'}), 400
    hashed_password = generate_password_hash(data['password'], method='sha256')
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO users (username, password) VALUES (?, ?)", (data['username'], hashed_password))
        conn.commit()
        logging.info(f"User registered: {data['username']}")
        return jsonify({'message': 'Registered successfully'}), 201
    except sqlite3.IntegrityError:
        return jsonify({'message': 'Username already exists'}), 400
    finally:
        conn.close()

@app.route('/login', methods=['POST'])
def login():
    auth = request.authorization
    if not auth or not auth.username or not auth.password:
        return jsonify({'message': 'Could not verify'}), 401
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE username=?", (auth.username,))
    user = cursor.fetchone()
    conn.close()
    if user and check_password_hash(user[2], auth.password):
        token = jwt.encode({'user': auth.username, 'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)},
                           app.config['SECRET_KEY'], algorithm="HS256")
        logging.info(f"User logged in: {auth.username}")
        return jsonify({'token': token})
    return jsonify({'message': 'Could not verify'}), 401

@app.route('/get_books', methods=['GET'])
@token_required
def get_books():
    author = request.args.get('author')
    year = request.args.get('year')
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    query = "SELECT * FROM books WHERE author = '{}' AND year = {}".format(author, year)
    cursor.execute(query)
    books = cursor.fetchall()
    conn.close()
    return jsonify(books)

@app.route('/add_book', methods=['POST'])
@token_required
def add_book():
    data = request.get_json()
    if not data or 'title' not in data or 'author' not in data or 'year' not in data:
        return jsonify({'message': 'Invalid input'}), 400
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute("INSERT INTO books (title, author, year) VALUES (?, ?, ?)",
                   (data['title'], data['author'], data['year']))
    conn.commit()
    book_id = cursor.lastrowid
    conn.close()
    logging.info(f"Book added: {data['title']} by {data['author']}")
    return jsonify({'message': 'Book added successfully', 'id': book_id}), 201

@app.route('/book/<int:book_id>', methods=['GET'])
@token_required
def get_book(book_id):
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM books WHERE id = ?", (book_id,))
    book = cursor.fetchone()
    conn.close()
    if book:
        return jsonify({'id': book[0], 'title': book[1], 'author': book[2], 'year': book[3]})
    return jsonify({'message': 'Book not found'}), 404

@app.route('/book/<int:book_id>', methods=['PUT'])
@token_required
def update_book(book_id):
    data = request.get_json()
    if not data:
        return jsonify({'message': 'No input data provided'}), 400
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    query = "UPDATE books SET "
    params = []
    if 'title' in data:
        query += "title = ?, "
        params.append(data['title'])
    if 'author' in data:
        query += "author = ?, "
        params.append(data['author'])
    if 'year' in data:
        query += "year = ?, "
        params.append(data['year'])
    query = query.rstrip(', ') + " WHERE id = ?"
    params.append(book_id)
    cursor.execute(query, tuple(params))
    conn.commit()
    conn.close()
    logging.info(f"Book updated: ID {book_id}")
    return jsonify({'message': 'Book updated successfully'})

@app.route('/book/<int:book_id>', methods=['DELETE'])
@token_required
def delete_book(book_id):
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute("DELETE FROM books WHERE id = ?", (book_id,))
    if cursor.rowcount == 0:
        conn.close()
        return jsonify({'message': 'Book not found'}), 404
    conn.commit()
    conn.close()
    logging.info(f"Book deleted: ID {book_id}")
    return jsonify({'message': 'Book deleted successfully'})

@app.route('/search_books', methods=['GET'])
@token_required
def search_books():
    title = request.args.get('title', '')
    author = request.args.get('author', '')
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    query = "SELECT * FROM books WHERE title LIKE ? AND author LIKE ?"
    cursor.execute(query, (f'%{title}%', f'%{author}%'))
    books = cursor.fetchall()
    conn.close()
    return jsonify([{'id': book[0], 'title': book[1], 'author': book[2], 'year': book[3]} for book in books])

def validate_book_data(data):
    if not isinstance(data.get('title'), str) or not isinstance(data.get('author'), str):
        return False
    if not isinstance(data.get('year'), int) or data['year'] < 0 or data['year'] > datetime.datetime.now().year:
        return False
    return True

@app.errorhandler(404)
def not_found(error):
    return jsonify({'message': 'Resource not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    logging.error(f"Internal server error: {str(error)}")
    return jsonify({'message': 'Internal server error'}), 500

if __name__ == '__main__':
    init_db()
    app.run(debug=True)