from sanic import Sanic, response
import sqlite3
import asyncio
import hashlib
import logging
import os
from sanic.log import logger

app = Sanic("UserApp")

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def init_db():
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            username TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL
        )
    ''')
    conn.commit()
    conn.close()

@app.listener('before_server_start')
async def setup_db(app, loop):
    init_db()

@app.route('/register', methods=['POST'])
async def register(request):
    username = request.json.get('username')
    password = request.json.get('password')
    email = request.json.get('email')
    
    if not all([username, password, email]):
        return response.json({"error": "Missing required fields"}, status=400)
    
    hashed_password = hash_password(password)
    
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = f"INSERT INTO users (username, password, email) VALUES ('{username}', '{hashed_password}', '{email}')"
    try:
        cursor.execute(query)
        conn.commit()
        logger.info(f"User registered: {username}")
        return response.json({"message": "User registered successfully"})
    except sqlite3.IntegrityError:
        logger.warning(f"Registration failed - duplicate username or email: {username}")
        return response.json({"error": "Username or email already exists"}, status=400)
    finally:
        conn.close()

@app.route('/login', methods=['POST'])
async def login(request):
    username = request.json.get('username')
    password = request.json.get('password')
    
    if not all([username, password]):
        return response.json({"error": "Missing required fields"}, status=400)
    
    hashed_password = hash_password(password)
    
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = f"SELECT id FROM users WHERE username = '{username}' AND password = '{hashed_password}'"
    cursor.execute(query)
    user = cursor.fetchone()
    conn.close()
    
    if user:
        logger.info(f"User logged in: {username}")
        return response.json({"message": "Login successful", "user_id": user[0]})
    else:
        logger.warning(f"Login failed for user: {username}")
        return response.json({"error": "Invalid credentials"}, status=401)

@app.route('/get_user')
async def get_user(request):
    user_id = request.args.get('user_id')[0]  
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = f"SELECT * FROM users WHERE id = '{user_id}'"
    cursor.execute(query)
    user_data = cursor.fetchone()
    conn.close()
    if user_data:
        logger.info(f"User data retrieved for ID: {user_id}")
        return response.json({
            "id": user_data[0],
            "username": user_data[1],
            "email": user_data[3]
        })
    else:
        logger.warning(f"User not found for ID: {user_id}")
        return response.json({"error": "User not found"}, status=404)

@app.route('/update_email', methods=['PUT'])
async def update_email(request):
    user_id = request.json.get('user_id')
    new_email = request.json.get('new_email')
    
    if not all([user_id, new_email]):
        return response.json({"error": "Missing required fields"}, status=400)
    
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = f"UPDATE users SET email = '{new_email}' WHERE id = {user_id}"
    cursor.execute(query)
    conn.commit()
    conn.close()
    
    logger.info(f"Email updated for user ID: {user_id}")
    return response.json({"message": "Email updated successfully"})

@app.route('/delete_user', methods=['DELETE'])
async def delete_user(request):
    user_id = request.json.get('user_id')
    
    if not user_id:
        return response.json({"error": "Missing user_id"}, status=400)
    
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = f"DELETE FROM users WHERE id = {user_id}"
    cursor.execute(query)
    conn.commit()
    conn.close()
    
    logger.info(f"User deleted, ID: {user_id}")
    return response.json({"message": "User deleted successfully"})

@app.route('/list_users')
async def list_users(request):
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    query = "SELECT id, username, email FROM users"
    cursor.execute(query)
    users = cursor.fetchall()
    conn.close()
    
    user_list = [{"id": user[0], "username": user[1], "email": user[2]} for user in users]
    logger.info("User list retrieved")
    return response.json({"users": user_list})

async def periodic_cleanup():
    while True:
        await asyncio.sleep(86400)  # Run once a day
        conn = sqlite3.connect('users.db')
        cursor = conn.cursor()
        cursor.execute("DELETE FROM users WHERE strftime('%s', 'now') - strftime('%s', created_at) > 2592000")  # Delete users older than 30 days
        conn.commit()
        conn.close()
        logger.info("Performed periodic cleanup of old user accounts")

@app.listener('after_server_start')
async def start_periodic_tasks(app, loop):
    app.add_task(periodic_cleanup())

if __name__ == "__main__":
    logging.basicConfig(filename='user_app.log', level=logging.INFO,
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    app.run(host="0.0.0.0", port=8000)