from fastapi import FastAPI, UploadFile, File, HTTPException, Depends
from fastapi.security import APIKeyHeader
from typing import List, Dict, Optional
import xml.etree.ElementTree as ET
import json
import logging
import uuid
from datetime import datetime
from pydantic import BaseModel

app = FastAPI()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Simulated database of flights
flights_db: List[Dict] = [
    {"id": 1, "from": "New York", "to": "London", "date": "2023-07-01", "seats": 100},
    {"id": 2, "from": "London", "to": "Paris", "date": "2023-07-02", "seats": 150},
    {"id": 3, "from": "Tokyo", "to": "Sydney", "date": "2023-07-03", "seats": 200},
]

# Simulated database of bookings
bookings_db: List[Dict] = []

# Simulated API key for authentication
API_KEY = "secret_api_key"
api_key_header = APIKeyHeader(name="X-API-Key")

class Flight(BaseModel):
    id: int
    from_city: str
    to_city: str
    date: str
    seats: int

class Booking(BaseModel):
    id: str
    flight_id: int
    passenger_name: str
    passport_number: str

def verify_api_key(api_key: str = Depends(api_key_header)):
    if api_key != API_KEY:
        raise HTTPException(status_code=403, detail="Invalid API Key")
    return api_key

@app.get("/search_flights")
async def search_flights(from_city: str, to_city: str, date: str):
    logger.info(f"Searching flights from {from_city} to {to_city} on {date}")
    matching_flights = [
        flight for flight in flights_db
        if flight["from"] == from_city and flight["to"] == to_city and flight["date"] == date
    ]
    return {"flights": matching_flights}

@app.post("/book_flight")
async def book_flight(file: UploadFile = File(...), api_key: str = Depends(verify_api_key)):
    logger.info("Processing flight booking")
    xml_data = await file.read()
    try:
        booking_details = ET.fromstring(xml_data)
        flight_id = int(booking_details.find("flight_id").text)
        passenger_name = booking_details.find("passenger_name").text
        passport_number = booking_details.find("passport_number").text
    except (ET.ParseError, AttributeError, ValueError) as e:
        logger.error(f"Invalid XML data: {str(e)}")
        raise HTTPException(status_code=400, detail="Invalid XML data")

    for flight in flights_db:
        if flight["id"] == flight_id:
            if flight["seats"] > 0:
                flight["seats"] -= 1
                booking_id = str(uuid.uuid4())
                new_booking = {
                    "id": booking_id,
                    "flight_id": flight_id,
                    "passenger_name": passenger_name,
                    "passport_number": passport_number,
                }
                bookings_db.append(new_booking)
                logger.info(f"Flight booked successfully. Booking ID: {booking_id}")
                return {
                    "message": "Flight booked successfully",
                    "booking_details": new_booking
                }
            else:
                logger.warning(f"No seats available for flight {flight_id}")
                raise HTTPException(status_code=400, detail="No seats available")
    
    logger.error(f"Flight not found: {flight_id}")
    raise HTTPException(status_code=404, detail="Flight not found")

@app.get("/flight/{flight_id}")
async def get_flight(flight_id: int):
    logger.info(f"Fetching flight details for ID: {flight_id}")
    for flight in flights_db:
        if flight["id"] == flight_id:
            return flight
    logger.error(f"Flight not found: {flight_id}")
    raise HTTPException(status_code=404, detail="Flight not found")

@app.put("/update_flight/{flight_id}")
async def update_flight(flight_id: int, updated_flight: Flight, api_key: str = Depends(verify_api_key)):
    logger.info(f"Updating flight: {flight_id}")
    for i, flight in enumerate(flights_db):
        if flight["id"] == flight_id:
            flights_db[i].update(updated_flight.dict())
            logger.info(f"Flight {flight_id} updated successfully")
            return {"message": "Flight updated successfully"}
    logger.error(f"Flight not found: {flight_id}")
    raise HTTPException(status_code=404, detail="Flight not found")

@app.delete("/delete_flight/{flight_id}")
async def delete_flight(flight_id: int, api_key: str = Depends(verify_api_key)):
    logger.info(f"Deleting flight: {flight_id}")
    for i, flight in enumerate(flights_db):
        if flight["id"] == flight_id:
            del flights_db[i]
            logger.info(f"Flight {flight_id} deleted successfully")
            return {"message": "Flight deleted successfully"}
    logger.error(f"Flight not found: {flight_id}")
    raise HTTPException(status_code=404, detail="Flight not found")

@app.get("/bookings/{booking_id}")
async def get_booking(booking_id: str, api_key: str = Depends(verify_api_key)):
    logger.info(f"Fetching booking details for ID: {booking_id}")
    for booking in bookings_db:
        if booking["id"] == booking_id:
            return booking
    logger.error(f"Booking not found: {booking_id}")
    raise HTTPException(status_code=404, detail="Booking not found")

@app.put("/update_booking/{booking_id}")
async def update_booking(booking_id: str, updated_booking: Booking, api_key: str = Depends(verify_api_key)):
    logger.info(f"Updating booking: {booking_id}")
    for i, booking in enumerate(bookings_db):
        if booking["id"] == booking_id:
            bookings_db[i].update(updated_booking.dict())
            logger.info(f"Booking {booking_id} updated successfully")
            return {"message": "Booking updated successfully"}
    logger.error(f"Booking not found: {booking_id}")
    raise HTTPException(status_code=404, detail="Booking not found")

@app.delete("/delete_booking/{booking_id}")
async def delete_booking(booking_id: str, api_key: str = Depends(verify_api_key)):
    logger.info(f"Deleting booking: {booking_id}")
    for i, booking in enumerate(bookings_db):
        if booking["id"] == booking_id:
            del bookings_db[i]
            logger.info(f"Booking {booking_id} deleted successfully")
            return {"message": "Booking deleted successfully"}
    logger.error(f"Booking not found: {booking_id}")
    raise HTTPException(status_code=404, detail="Booking not found")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)