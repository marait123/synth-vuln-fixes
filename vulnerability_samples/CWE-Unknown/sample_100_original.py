import sqlite3
from fastapi import FastAPI, Query, Request, HTTPException, Depends, Form
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel, Field
import logging
import os
import jwt
from datetime import datetime, timedelta
from typing import Optional

app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Database setup
conn = sqlite3.connect('example.db')
c = conn.cursor()
c.execute('''CREATE TABLE IF NOT EXISTS users
             (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT, email TEXT)''')
conn.commit()

# Logging setup
logging.basicConfig(filename='app.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

class User(BaseModel):
    username: str
    password: str
    email: str = Field(..., regex=r"^[\w\.-]+@[\w\.-]+\.\w+$")

class UserInDB(User):
    id: int

class Token(BaseModel):
    access_token: str
    token_type: str

SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

def get_db():
    db = sqlite3.connect('example.db')
    try:
        yield db
    finally:
        db.close()

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

@app.post("/register", response_model=UserInDB)
async def register(user: User, db: sqlite3.Connection = Depends(get_db)):
    c = db.cursor()
    try:
        c.execute("INSERT INTO users (username, password, email) VALUES (?, ?, ?)",
                  (user.username, user.password, user.email))
        db.commit()
        user_id = c.lastrowid
        logging.info(f"User registered: {user.username}")
        return UserInDB(id=user_id, **user.dict())
    except sqlite3.IntegrityError:
        raise HTTPException(status_code=400, detail="Username already exists")

@app.post("/token", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends(), db: sqlite3.Connection = Depends(get_db)):
    c = db.cursor()
    c.execute("SELECT * FROM users WHERE username=? AND password=?", (form_data.username, form_data.password))
    user = c.fetchone()
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user[1]}, expires_delta=access_token_expires
    )
    logging.info(f"User logged in: {form_data.username}")
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/user/{user_id}", response_model=UserInDB)
async def get_user(user_id: int, db: sqlite3.Connection = Depends(get_db)):
    c = db.cursor()
    c.execute("SELECT * FROM users WHERE id=?", (user_id,))
    user = c.fetchone()
    if user:
        return UserInDB(id=user[0], username=user[1], password="*****", email=user[3])
    raise HTTPException(status_code=404, detail="User not found")

@app.put("/user/{user_id}")
async def update_user(user_id: int, user: User, db: sqlite3.Connection = Depends(get_db)):
    c = db.cursor()
    c.execute("UPDATE users SET username=?, password=?, email=? WHERE id=?",
              (user.username, user.password, user.email, user_id))
    db.commit()
    if c.rowcount == 0:
        raise HTTPException(status_code=404, detail="User not found")
    logging.info(f"User updated: {user_id}")
    return {"message": "User updated successfully"}

@app.delete("/user/{user_id}")
async def delete_user(user_id: int, db: sqlite3.Connection = Depends(get_db)):
    c = db.cursor()
    c.execute("DELETE FROM users WHERE id=?", (user_id,))
    db.commit()
    if c.rowcount == 0:
        raise HTTPException(status_code=404, detail="User not found")
    logging.info(f"User deleted: {user_id}")
    return {"message": "User deleted successfully"}

@app.get('/write_data_from_request')
def write_data_from_request(request: Request):
    data = request.query_params.get('data')
    filename = 'output.txt'
    with open(filename, 'w') as f:
        f.write(data)
    logging.info(f"Data written to file: {data}")
    return {"message": "Data written successfully", "filename": filename}

@app.get("/protected")
async def protected_route(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    return {"message": "This is a protected route", "username": username}

@app.get("/")
async def root():
    return {"message": "Welcome to the User Management API"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)