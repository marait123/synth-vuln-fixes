from sanic import Sanic, response
import logging
from sqlalchemy import create_engine, Column, Integer, String, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import bcrypt
import datetime
import json
import os

# Logger setup
logger = logging.getLogger('app_logger')
logger.setLevel(logging.DEBUG)
fh = logging.FileHandler('app.log')
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
logger.addHandler(fh)

app = Sanic("ExpandedApp")

# Database setup
engine = create_engine('sqlite:///users.db')
Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True)
    password = Column(String(100))
    email = Column(String(100), unique=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    last_login = Column(DateTime)

Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)

def validate_password(password):
    if len(password) < 8:
        return False
    if not any(char.isdigit() for char in password):
        return False
    if not any(char.isupper() for char in password):
        return False
    return True

@app.route('/register', methods=['POST'])
async def register(request):
    username = request.json.get('username')
    password = request.json.get('password')
    email = request.json.get('email')
    
    if not username or not password or not email:
        return response.json({"error": "Missing username, password, or email"}, status=400)
    
    if not validate_password(password):
        return response.json({"error": "Password does not meet complexity requirements"}, status=400)
    
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
    
    session = Session()
    try:
        new_user = User(username=username, password=hashed_password, email=email)
        session.add(new_user)
        session.commit()
        logger.info(f"New user registered: {username}")
        return response.json({"status": "User registered successfully"})
    except Exception as e:
        session.rollback()
        logger.error(f"Error registering user: {str(e)}")
        return response.json({"error": "Registration failed"}, status=500)
    finally:
        session.close()

@app.route('/login', methods=['POST'])
async def login(request):
    username = request.json.get('username')
    password = request.json.get('password')
    
    if not username or not password:
        return response.json({"error": "Missing username or password"}, status=400)
    
    session = Session()
    try:
        user = session.query(User).filter_by(username=username).first()
        if user and bcrypt.checkpw(password.encode('utf-8'), user.password):
            user.last_login = datetime.datetime.utcnow()
            session.commit()
            logger.info(f"User logged in: {username}")
            return response.json({"status": "Login successful"})
        else:
            logger.warning(f"Failed login attempt for user: {username}")
            return response.json({"error": "Invalid credentials"}, status=401)
    except Exception as e:
        logger.error(f"Error during login: {str(e)}")
        return response.json({"error": "Login failed"}, status=500)
    finally:
        session.close()

@app.route('/process', methods=['POST'])
async def process_data(request):
    api_key = request.json.get('api_key')
    logger.debug(f'Processing data with API key: {api_key}')  # Vulnerable line
    # Simulating data processing
    try:
        # Placeholder for actual data processing logic
        processed_data = {"result": "Data processed successfully"}
        logger.info("Data processing completed")
        return response.json(processed_data)
    except Exception as e:
        logger.error(f"Error processing data: {str(e)}")
        return response.json({"error": "Data processing failed"}, status=500)

@app.route('/users', methods=['GET'])
async def get_users(request):
    session = Session()
    try:
        users = session.query(User).all()
        user_list = [{"id": user.id, "username": user.username, "email": user.email, "created_at": user.created_at.isoformat()} for user in users]
        logger.info("User list retrieved")
        return response.json({"users": user_list})
    except Exception as e:
        logger.error(f"Error retrieving user list: {str(e)}")
        return response.json({"error": "Failed to retrieve users"}, status=500)
    finally:
        session.close()

@app.route('/user/<user_id:int>', methods=['GET', 'PUT', 'DELETE'])
async def manage_user(request, user_id):
    session = Session()
    try:
        user = session.query(User).filter_by(id=user_id).first()
        if not user:
            return response.json({"error": "User not found"}, status=404)
        
        if request.method == 'GET':
            user_data = {"id": user.id, "username": user.username, "email": user.email, "created_at": user.created_at.isoformat()}
            return response.json(user_data)
        elif request.method == 'PUT':
            new_email = request.json.get('email')
            if new_email:
                user.email = new_email
                session.commit()
                logger.info(f"User {user_id} updated")
                return response.json({"status": "User updated successfully"})
        elif request.method == 'DELETE':
            session.delete(user)
            session.commit()
            logger.info(f"User {user_id} deleted")
            return response.json({"status": "User deleted successfully"})
    except Exception as e:
        session.rollback()
        logger.error(f"Error managing user {user_id}: {str(e)}")
        return response.json({"error": "Operation failed"}, status=500)
    finally:
        session.close()

@app.listener('before_server_start')
async def setup(app, loop):
    logger.info("Server starting up...")

@app.listener('after_server_stop')
async def cleanup(app, loop):
    logger.info("Server shutting down...")

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)