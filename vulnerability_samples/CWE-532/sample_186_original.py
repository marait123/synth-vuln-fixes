import logging
import random
import time
import sqlite3
from datetime import datetime
import hashlib
import argparse

class DatabaseManager:
    def __init__(self, db_name='transactions.db'):
        self.conn = sqlite3.connect(db_name)
        self.cursor = self.conn.cursor()
        self.create_tables()

    def create_tables(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS transactions (
                id TEXT PRIMARY KEY,
                user_id TEXT,
                amount REAL,
                status TEXT,
                timestamp DATETIME
            )
        ''')
        self.conn.commit()

    def insert_transaction(self, transaction_id, user_id, amount, status):
        self.cursor.execute('''
            INSERT INTO transactions (id, user_id, amount, status, timestamp)
            VALUES (?, ?, ?, ?, ?)
        ''', (transaction_id, user_id, amount, status, datetime.now()))
        self.conn.commit()

    def update_transaction_status(self, transaction_id, status):
        self.cursor.execute('''
            UPDATE transactions SET status = ? WHERE id = ?
        ''', (status, transaction_id))
        self.conn.commit()

    def get_transaction(self, transaction_id):
        self.cursor.execute('SELECT * FROM transactions WHERE id = ?', (transaction_id,))
        return self.cursor.fetchone()

    def close(self):
        self.conn.close()

class TransactionHandler:
    def __init__(self, logger_name='transaction_logger', db_manager=None):
        self.logger = logging.getLogger(logger_name)
        self.logger.setLevel(logging.INFO)
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.db_manager = db_manager or DatabaseManager()

    def generate_transaction_id(self):
        return f"TXN-{random.randint(100000, 999999)}"

    def initialize_transaction(self, user_id, amount):
        transaction_id = self.generate_transaction_id()
        self.logger.info(f"Initializing transaction {transaction_id} for user {user_id} with amount {amount}")
        self.db_manager.insert_transaction(transaction_id, user_id, amount, 'initialized')
        return transaction_id

    def process_transaction(self, transaction_id, api_secret):
        self.logger.info(f"Processing transaction {transaction_id} with API secret: {api_secret}")
        time.sleep(1)  # Simulating processing time
        success = random.choice([True, False])
        return success

    def finalize_transaction(self, transaction_id, success):
        status = "completed" if success else "failed"
        self.logger.info(f"Transaction {transaction_id} {status}")
        self.db_manager.update_transaction_status(transaction_id, status)

    def get_transaction_details(self, transaction_id):
        return self.db_manager.get_transaction(transaction_id)

class APIKeyManager:
    @staticmethod
    def hash_api_key(api_key):
        return hashlib.sha256(api_key.encode()).hexdigest()

    @staticmethod
    def verify_api_key(api_key, stored_hash):
        return APIKeyManager.hash_api_key(api_key) == stored_hash

class CustomException(Exception):
    pass

class InvalidAmountException(CustomException):
    pass

class InvalidAPIKeyException(CustomException):
    pass

def validate_amount(amount):
    if not isinstance(amount, (int, float)) or amount <= 0:
        raise InvalidAmountException("Invalid amount. Must be a positive number.")

def validate_api_key(api_key):
    # In a real scenario, this would check against a database of valid API keys
    valid_api_key_hash = "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8"  # hash of "password"
    if not APIKeyManager.verify_api_key(api_key, valid_api_key_hash):
        raise InvalidAPIKeyException("Invalid API key")

def main():
    parser = argparse.ArgumentParser(description="Process a transaction")
    parser.add_argument("user_id", help="User ID")
    parser.add_argument("amount", type=float, help="Transaction amount")
    parser.add_argument("api_key", help="API key for authentication")
    args = parser.parse_args()

    handler = TransactionHandler()
    
    try:
        validate_amount(args.amount)
        validate_api_key(args.api_key)

        transaction_id = handler.initialize_transaction(args.user_id, args.amount)
        success = handler.process_transaction(transaction_id, args.api_key)
        handler.finalize_transaction(transaction_id, success)

        print(f"Transaction details: {handler.get_transaction_details(transaction_id)}")

    except CustomException as e:
        print(f"Error: {str(e)}")
    except Exception as e:
        print(f"Unexpected error: {str(e)}")
    finally:
        handler.db_manager.close()

if __name__ == "__main__":
    main()