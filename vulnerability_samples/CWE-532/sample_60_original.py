import logging
from bottle import route, run, request, response, abort
import hashlib
import sqlite3
import re
import json
from datetime import datetime

# Logger setup
logger = logging.getLogger('user_logger')
logger.setLevel(logging.INFO)
fh = logging.FileHandler('user_activity.log')
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
logger.addHandler(fh)

# Database setup
conn = sqlite3.connect('users.db')
c = conn.cursor()
c.execute('''CREATE TABLE IF NOT EXISTS users
             (username TEXT PRIMARY KEY, password TEXT, email TEXT, created_at TEXT)''')
conn.commit()

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def validate_email(email):
    return re.match(r"[^@]+@[^@]+\.[^@]+", email)

def validate_password(password):
    return len(password) >= 8

def json_response(data, status=200):
    response.content_type = 'application/json'
    response.status = status
    return json.dumps(data)

@route('/register', method='POST')
def register():
    username = request.forms.get('username')
    password = request.forms.get('password')
    email = request.forms.get('email')
    
    if not username or not password or not email:
        logger.warning('Registration failed: missing required fields')
        return json_response({"error": "All fields are required"}, 400)
    
    if not validate_email(email):
        logger.warning('Registration failed: invalid email format')
        return json_response({"error": "Invalid email format"}, 400)
    
    if not validate_password(password):
        logger.warning('Registration failed: password too short')
        return json_response({"error": "Password must be at least 8 characters long"}, 400)
    
    hashed_password = hash_password(password)
    created_at = datetime.now().isoformat()
    
    try:
        c.execute("INSERT INTO users VALUES (?, ?, ?, ?)", (username, hashed_password, email, created_at))
        conn.commit()
        logger.info('New user registered: %s', username)
        return json_response({"message": "Registration successful"})
    except sqlite3.IntegrityError:
        logger.warning('Registration failed: username %s already exists', username)
        return json_response({"error": "Username already exists"}, 409)

@route('/login', method='POST')
def login():
    username = request.forms.get('username')
    password = request.forms.get('password')
    
    if not username or not password:
        logger.warning('Login failed: missing required fields')
        return json_response({"error": "Username and password are required"}, 400)
    
    c.execute("SELECT password FROM users WHERE username=?", (username,))
    result = c.fetchone()
    
    if result and result[0] == hash_password(password):
        logger.info('User %s logged in successfully', username)
        return json_response({"message": "Login successful"})
    else:
        logger.warning('Failed login attempt for user: %s', username)
        return json_response({"error": "Invalid username or password"}, 401)

@route('/profile/<username>')
def profile(username):
    c.execute("SELECT email, created_at FROM users WHERE username=?", (username,))
    result = c.fetchone()
    
    if result:
        logger.info('Profile viewed for user: %s', username)
        return json_response({
            "username": username,
            "email": result[0],
            "created_at": result[1]
        })
    else:
        logger.warning('Profile not found for user: %s', username)
        return json_response({"error": "User not found"}, 404)

@route('/change_password', method='POST')
def change_password():
    username = request.forms.get('username')
    old_password = request.forms.get('old_password')
    new_password = request.forms.get('new_password')
    
    if not username or not old_password or not new_password:
        logger.warning('Password change failed: missing required fields')
        return json_response({"error": "All fields are required"}, 400)
    
    if not validate_password(new_password):
        logger.warning('Password change failed: new password too short')
        return json_response({"error": "New password must be at least 8 characters long"}, 400)
    
    c.execute("SELECT password FROM users WHERE username=?", (username,))
    result = c.fetchone()
    
    if result and result[0] == hash_password(old_password):
        new_hashed_password = hash_password(new_password)
        c.execute("UPDATE users SET password=? WHERE username=?", (new_hashed_password, username))
        conn.commit()
        logger.info('Password changed for user: %s', username)
        return json_response({"message": "Password changed successfully"})
    else:
        logger.warning('Failed password change attempt for user: %s', username)
        return json_response({"error": "Invalid username or old password"}, 401)

@route('/delete_account', method='POST')
def delete_account():
    username = request.forms.get('username')
    password = request.forms.get('password')
    
    if not username or not password:
        logger.warning('Account deletion failed: missing required fields')
        return json_response({"error": "Username and password are required"}, 400)
    
    c.execute("SELECT password FROM users WHERE username=?", (username,))
    result = c.fetchone()
    
    if result and result[0] == hash_password(password):
        c.execute("DELETE FROM users WHERE username=?", (username,))
        conn.commit()
        logger.info('Account deleted for user: %s', username)
        return json_response({"message": "Account deleted successfully"})
    else:
        logger.warning('Failed account deletion attempt for user: %s', username)
        return json_response({"error": "Invalid username or password"}, 401)

@route('/users', method='GET')
def list_users():
    c.execute("SELECT username, email, created_at FROM users")
    users = [{"username": row[0], "email": row[1], "created_at": row[2]} for row in c.fetchall()]
    return json_response({"users": users})

if __name__ == '__main__':
    run(host='localhost', port=8080, debug=True)