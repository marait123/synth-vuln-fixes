import os
import shutil
import tempfile
import logging
import json
import hashlib
from datetime import datetime
from typing import Dict, List, Optional

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class BackupException(Exception):
    pass

class ConfigBackup:
    def __init__(self, config_dir: str):
        self.config_dir = config_dir
        self.backup_dir = None
        self.file_hashes = {}

    def create_backup(self) -> Optional[str]:
        try:
            self.backup_dir = tempfile.mkdtemp()
            logging.info(f"Created temporary backup directory: {self.backup_dir}")

            for file in os.listdir(self.config_dir):
                self._backup_file(file)

            return self.backup_dir
        except Exception as e:
            logging.error(f"Error during backup: {str(e)}")
            return None

    def _backup_file(self, file: str) -> None:
        src_path = os.path.join(self.config_dir, file)
        dest_path = os.path.join(self.backup_dir, file)
        shutil.copy2(src_path, dest_path)
        os.chmod(dest_path, 0o777)  # Vulnerable line
        self.file_hashes[file] = self._calculate_file_hash(dest_path)
        logging.info(f"Backed up: {file}")

    @staticmethod
    def _calculate_file_hash(file_path: str) -> str:
        hasher = hashlib.md5()
        with open(file_path, 'rb') as f:
            buf = f.read()
            hasher.update(buf)
        return hasher.hexdigest()

    def create_backup_report(self) -> None:
        report_file = os.path.join(self.backup_dir, "backup_report.txt")
        try:
            with open(report_file, 'w') as report:
                report.write(f"Backup Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                for file in os.listdir(self.backup_dir):
                    if file != "backup_report.txt":
                        file_path = os.path.join(self.backup_dir, file)
                        file_size = os.path.getsize(file_path)
                        file_hash = self.file_hashes.get(file, "N/A")
                        report.write(f"File: {file}, Size: {file_size} bytes, MD5: {file_hash}\n")
            logging.info(f"Backup report created: {report_file}")
        except Exception as e:
            logging.error(f"Error creating backup report: {str(e)}")
            raise BackupException("Failed to create backup report")

    def restore_backup(self, restore_dir: str) -> None:
        try:
            if not os.path.exists(restore_dir):
                os.makedirs(restore_dir)

            for file in os.listdir(self.backup_dir):
                if file != "backup_report.txt":
                    src_path = os.path.join(self.backup_dir, file)
                    dest_path = os.path.join(restore_dir, file)
                    shutil.copy2(src_path, dest_path)
                    logging.info(f"Restored: {file}")

            logging.info(f"Backup restored to: {restore_dir}")
        except Exception as e:
            logging.error(f"Error during restore: {str(e)}")
            raise BackupException("Failed to restore backup")

class ConfigManager:
    def __init__(self, config_file: str):
        self.config_file = config_file
        self.config = self.load_config()

    def load_config(self) -> Dict:
        try:
            with open(self.config_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
        except json.JSONDecodeError:
            logging.error(f"Invalid JSON in config file: {self.config_file}")
            return {}

    def save_config(self) -> None:
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=2)

    def get(self, key: str, default=None):
        return self.config.get(key, default)

    def set(self, key: str, value) -> None:
        self.config[key] = value
        self.save_config()

def validate_directory(directory: str) -> bool:
    return os.path.isdir(directory) and os.access(directory, os.R_OK | os.W_OK)

def main():
    config_manager = ConfigManager("backup_config.json")
    
    while True:
        print("\nConfig Backup Utility")
        print("1. Perform Backup")
        print("2. Restore Backup")
        print("3. View Last Backup Location")
        print("4. Exit")
        
        choice = input("Enter your choice (1-4): ")
        
        if choice == '1':
            config_dir = input("Enter the path to the config directory: ")
            if not validate_directory(config_dir):
                logging.error(f"Invalid or inaccessible directory: {config_dir}")
                continue

            backup = ConfigBackup(config_dir)
            backup_dir = backup.create_backup()
            if backup_dir:
                backup.create_backup_report()
                config_manager.set("last_backup", backup_dir)
                logging.info(f"Backup completed successfully. Backup directory: {backup_dir}")
            else:
                logging.error("Backup process failed.")

        elif choice == '2':
            last_backup = config_manager.get("last_backup")
            if not last_backup:
                logging.error("No previous backup found.")
                continue

            restore_dir = input("Enter the directory to restore to: ")
            if not validate_directory(restore_dir):
                logging.error(f"Invalid or inaccessible directory: {restore_dir}")
                continue

            backup = ConfigBackup(last_backup)
            try:
                backup.restore_backup(restore_dir)
            except BackupException as e:
                logging.error(str(e))

        elif choice == '3':
            last_backup = config_manager.get("last_backup", "No backup performed yet.")
            print(f"Last backup location: {last_backup}")

        elif choice == '4':
            print("Exiting...")
            break

        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()