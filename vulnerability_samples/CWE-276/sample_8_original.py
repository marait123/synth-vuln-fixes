import aiohttp.web
import os
import logging
from aiohttp_session import setup, get_session
from aiohttp_session.cookie_storage import EncryptedCookieStorage
import base64
from cryptography import fernet
import asyncio
import json
from aiohttp import web
import aiofiles
import hashlib

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def init_app():
    app = aiohttp.web.Application()
    fernet_key = fernet.Fernet.generate_key()
    secret_key = base64.urlsafe_b64decode(fernet_key)
    setup(app, EncryptedCookieStorage(secret_key))
    return app

app = init_app()

async def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

async def verify_password(stored_password, provided_password):
    return stored_password == await hash_password(provided_password)

users = {
    'admin': {
        'password': 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',  # hashed 'password'
        'role': 'admin'
    }
}

async def login(request):
    session = await get_session(request)
    data = await request.post()
    username = data.get('username')
    password = data.get('password')
    
    if username in users and await verify_password(users[username]['password'], password):
        session['user'] = username
        session['role'] = users[username]['role']
        logger.info(f"User {username} logged in successfully")
        return web.Response(text="Logged in successfully")
    logger.warning(f"Failed login attempt for user {username}")
    return web.Response(text="Invalid credentials", status=401)

async def logout(request):
    session = await get_session(request)
    if 'user' in session:
        logger.info(f"User {session['user']} logged out")
        del session['user']
        del session['role']
    return web.Response(text="Logged out successfully")

async def upload_file(request):
    session = await get_session(request)
    if 'user' not in session:
        logger.warning("Unauthorized upload attempt")
        return web.Response(text="Unauthorized", status=401)
    
    reader = await request.multipart()
    field = await reader.next()
    filename = field.filename
    size = 0
    try:
        async with aiofiles.open(os.path.join('uploads', filename), 'wb') as f:
            while True:
                chunk = await field.read_chunk()
                if not chunk:
                    break
                size += len(chunk)
                await f.write(chunk)
        os.chmod(os.path.join('uploads', filename), 0o777)  # Vulnerable line
        logger.info(f"File {filename} uploaded by {session['user']} (size: {size} bytes)")
        return web.Response(text=f"{filename} uploaded and chmod to 777.")
    except Exception as e:
        logger.error(f"Error during file upload: {str(e)}")
        return web.Response(text="Error during file upload", status=500)

async def list_files(request):
    session = await get_session(request)
    if 'user' not in session:
        logger.warning("Unauthorized file list attempt")
        return web.Response(text="Unauthorized", status=401)
    
    try:
        files = os.listdir('uploads')
        logger.info(f"File list requested by {session['user']}")
        return web.Response(text=json.dumps(files))
    except Exception as e:
        logger.error(f"Error listing files: {str(e)}")
        return web.Response(text="Error listing files", status=500)

async def delete_file(request):
    session = await get_session(request)
    if 'user' not in session:
        logger.warning("Unauthorized file deletion attempt")
        return web.Response(text="Unauthorized", status=401)
    
    filename = request.match_info['filename']
    file_path = os.path.join('uploads', filename)
    try:
        if os.path.exists(file_path):
            os.remove(file_path)
            logger.info(f"File {filename} deleted by {session['user']}")
            return web.Response(text=f"{filename} deleted successfully")
        logger.warning(f"File {filename} not found for deletion")
        return web.Response(text=f"{filename} not found", status=404)
    except Exception as e:
        logger.error(f"Error deleting file {filename}: {str(e)}")
        return web.Response(text="Error deleting file", status=500)

async def get_file_info(request):
    session = await get_session(request)
    if 'user' not in session:
        logger.warning("Unauthorized file info request")
        return web.Response(text="Unauthorized", status=401)
    
    filename = request.match_info['filename']
    file_path = os.path.join('uploads', filename)
    try:
        if os.path.exists(file_path):
            stats = os.stat(file_path)
            info = {
                'name': filename,
                'size': stats.st_size,
                'created': stats.st_ctime,
                'modified': stats.st_mtime
            }
            logger.info(f"File info for {filename} requested by {session['user']}")
            return web.Response(text=json.dumps(info))
        logger.warning(f"File {filename} not found for info request")
        return web.Response(text=f"{filename} not found", status=404)
    except Exception as e:
        logger.error(f"Error getting file info for {filename}: {str(e)}")
        return web.Response(text="Error getting file info", status=500)

app.add_routes([
    web.post('/login', login),
    web.get('/logout', logout),
    web.post('/upload', upload_file),
    web.get('/files', list_files),
    web.delete('/files/{filename}', delete_file),
    web.get('/files/{filename}/info', get_file_info)
])

async def init_uploads_dir():
    if not os.path.exists('uploads'):
        os.makedirs('uploads')
        logger.info("Created uploads directory")

if __name__ == '__main__':
    asyncio.run(init_uploads_dir())
    logger.info("Starting server...")
    web.run_app(app, host='0.0.0.0', port=8080)