import socket
import threading
import json
import logging
import argparse
import sys
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Simple in-memory key-value store
data_store = {}

class DataStoreException(Exception):
    pass

def validate_key(key):
    if not isinstance(key, str) or len(key) == 0:
        raise DataStoreException("Invalid key: must be a non-empty string")

def validate_value(value):
    if not isinstance(value, (str, int, float, bool, list, dict)):
        raise DataStoreException("Invalid value type")

def handle_client(client_socket):
    client_address = client_socket.getpeername()
    logger.info(f"New connection from {client_address}")
    try:
        while True:
            data = client_socket.recv(1024).decode('utf-8')
            if not data:
                break
            
            try:
                request = json.loads(data)
                operation = request.get('operation')
                key = request.get('key')
                value = request.get('value')
                
                if operation == 'get':
                    validate_key(key)
                    response = {'result': data_store.get(key, 'Key not found')}
                elif operation == 'set':
                    validate_key(key)
                    validate_value(value)
                    data_store[key] = value
                    response = {'result': 'Success'}
                elif operation == 'delete':
                    validate_key(key)
                    if key in data_store:
                        del data_store[key]
                        response = {'result': 'Success'}
                    else:
                        response = {'result': 'Key not found'}
                elif operation == 'list':
                    response = {'result': list(data_store.keys())}
                else:
                    response = {'result': 'Invalid operation'}
                
                client_socket.sendall(json.dumps(response).encode('utf-8'))
            except json.JSONDecodeError:
                logger.error(f"Invalid JSON received from {client_address}")
                client_socket.sendall(json.dumps({'result': 'Invalid JSON'}).encode('utf-8'))
            except DataStoreException as e:
                logger.error(f"Data store error: {str(e)}")
                client_socket.sendall(json.dumps({'result': str(e)}).encode('utf-8'))
            except Exception as e:
                logger.error(f"Unexpected error: {str(e)}")
                client_socket.sendall(json.dumps({'result': 'Internal server error'}).encode('utf-8'))
    finally:
        logger.info(f"Connection closed from {client_address}")
        client_socket.close()

def start_server(host, port):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        server_socket.bind((host, port))
        server_socket.listen(5)
        logger.info(f"Server started on {host} at port {port}")
        
        while True:
            client_socket, addr = server_socket.accept()
            client_thread = threading.Thread(target=handle_client, args=(client_socket,))
            client_thread.start()
    except Exception as e:
        logger.error(f"Server error: {str(e)}")
    finally:
        server_socket.close()

def backup_data():
    with open(f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json", 'w') as f:
        json.dump(data_store, f)
    logger.info("Data backup created")

def restore_data(filename):
    global data_store
    with open(filename, 'r') as f:
        data_store = json.load(f)
    logger.info(f"Data restored from {filename}")

def run_tests():
    test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    test_socket.connect(('localhost', 8080))
    
    # Test set operation
    test_socket.sendall(json.dumps({'operation': 'set', 'key': 'test_key', 'value': 'test_value'}).encode('utf-8'))
    response = json.loads(test_socket.recv(1024).decode('utf-8'))
    assert response['result'] == 'Success', "Set operation failed"
    
    # Test get operation
    test_socket.sendall(json.dumps({'operation': 'get', 'key': 'test_key'}).encode('utf-8'))
    response = json.loads(test_socket.recv(1024).decode('utf-8'))
    assert response['result'] == 'test_value', "Get operation failed"
    
    # Test delete operation
    test_socket.sendall(json.dumps({'operation': 'delete', 'key': 'test_key'}).encode('utf-8'))
    response = json.loads(test_socket.recv(1024).decode('utf-8'))
    assert response['result'] == 'Success', "Delete operation failed"
    
    # Test list operation
    test_socket.sendall(json.dumps({'operation': 'list'}).encode('utf-8'))
    response = json.loads(test_socket.recv(1024).decode('utf-8'))
    assert isinstance(response['result'], list), "List operation failed"
    
    logger.info("All tests passed successfully")
    test_socket.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Simple key-value store server")
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind the server to')
    parser.add_argument('--port', type=int, default=8080, help='Port to bind the server to')
    parser.add_argument('--backup', action='store_true', help='Backup the data store')
    parser.add_argument('--restore', help='Restore data from a backup file')
    parser.add_argument('--test', action='store_true', help='Run tests')
    
    args = parser.parse_args()
    
    if args.backup:
        backup_data()
    elif args.restore:
        restore_data(args.restore)
    elif args.test:
        run_tests()
    else:
        start_server(args.host, args.port)