import asyncio
import socket
import aiohttp.web
import sqlite3
import logging
import os
import json
import hashlib
import secrets

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

DB_NAME = 'users.db'

def init_db():
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS users
                      (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT, salt TEXT)''')
    conn.commit()
    conn.close()

def hash_password(password, salt=None):
    if not salt:
        salt = secrets.token_hex(16)
    return hashlib.sha256((password + salt).encode()).hexdigest(), salt

async def tcp_socket_server():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('0.0.0.0', 1337))  # Vulnerable line
    server_socket.listen(5)
    server_socket.setblocking(False)

    while True:
        client_socket, addr = await loop.sock_accept(server_socket)
        logger.info(f"Accepted connection from {addr}")
        loop.create_task(handle_client(client_socket))

async def handle_client(client_socket):
    try:
        data = await loop.sock_recv(client_socket, 1024)
        if data:
            response = f"Received: {data.decode()}"
            await loop.sock_sendall(client_socket, response.encode())
    except Exception as e:
        logger.error(f"Error handling client: {str(e)}")
    finally:
        client_socket.close()

async def handle(request):
    return aiohttp.web.Response(text="Hello from aiohttp")

async def register(request):
    try:
        data = await request.json()
        username = data.get('username')
        password = data.get('password')

        if not username or not password:
            return aiohttp.web.json_response({"status": "error", "message": "Username and password are required"}, status=400)

        hashed_password, salt = hash_password(password)

        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        try:
            cursor.execute("INSERT INTO users (username, password, salt) VALUES (?, ?, ?)", (username, hashed_password, salt))
            conn.commit()
            return aiohttp.web.json_response({"status": "success", "message": "User registered successfully"})
        except sqlite3.IntegrityError:
            return aiohttp.web.json_response({"status": "error", "message": "Username already exists"}, status=409)
        finally:
            conn.close()
    except Exception as e:
        logger.error(f"Error in register: {str(e)}")
        return aiohttp.web.json_response({"status": "error", "message": "Internal server error"}, status=500)

async def login(request):
    try:
        data = await request.json()
        username = data.get('username')
        password = data.get('password')

        if not username or not password:
            return aiohttp.web.json_response({"status": "error", "message": "Username and password are required"}, status=400)

        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute("SELECT password, salt FROM users WHERE username=?", (username,))
        user = cursor.fetchone()
        conn.close()

        if user:
            stored_password, salt = user
            hashed_password, _ = hash_password(password, salt)
            if hashed_password == stored_password:
                return aiohttp.web.json_response({"status": "success", "message": "Login successful"})

        return aiohttp.web.json_response({"status": "error", "message": "Invalid credentials"}, status=401)
    except Exception as e:
        logger.error(f"Error in login: {str(e)}")
        return aiohttp.web.json_response({"status": "error", "message": "Internal server error"}, status=500)

async def get_user_data(request):
    try:
        user_id = request.match_info.get('id')
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute("SELECT id, username FROM users WHERE id=?", (user_id,))
        user = cursor.fetchone()
        conn.close()

        if user:
            return aiohttp.web.json_response({"id": user[0], "username": user[1]})
        else:
            return aiohttp.web.json_response({"error": "User not found"}, status=404)
    except Exception as e:
        logger.error(f"Error in get_user_data: {str(e)}")
        return aiohttp.web.json_response({"status": "error", "message": "Internal server error"}, status=500)

async def update_user(request):
    try:
        user_id = request.match_info.get('id')
        data = await request.json()
        new_username = data.get('username')

        if not new_username:
            return aiohttp.web.json_response({"status": "error", "message": "Username is required"}, status=400)

        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute("UPDATE users SET username=? WHERE id=?", (new_username, user_id))
        conn.commit()
        if cursor.rowcount == 0:
            conn.close()
            return aiohttp.web.json_response({"status": "error", "message": "User not found"}, status=404)
        conn.close()

        return aiohttp.web.json_response({"status": "success", "message": "User updated successfully"})
    except Exception as e:
        logger.error(f"Error in update_user: {str(e)}")
        return aiohttp.web.json_response({"status": "error", "message": "Internal server error"}, status=500)

async def delete_user(request):
    try:
        user_id = request.match_info.get('id')
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM users WHERE id=?", (user_id,))
        conn.commit()
        if cursor.rowcount == 0:
            conn.close()
            return aiohttp.web.json_response({"status": "error", "message": "User not found"}, status=404)
        conn.close()

        return aiohttp.web.json_response({"status": "success", "message": "User deleted successfully"})
    except Exception as e:
        logger.error(f"Error in delete_user: {str(e)}")
        return aiohttp.web.json_response({"status": "error", "message": "Internal server error"}, status=500)

app = aiohttp.web.Application()
app.add_routes([
    aiohttp.web.get('/', handle),
    aiohttp.web.post('/register', register),
    aiohttp.web.post('/login', login),
    aiohttp.web.get('/user/{id}', get_user_data),
    aiohttp.web.put('/user/{id}', update_user),
    aiohttp.web.delete('/user/{id}', delete_user)
])

if __name__ == '__main__':
    init_db()
    loop = asyncio.get_event_loop()
    loop.create_task(tcp_socket_server())
    aiohttp.web.run_app(app, host='0.0.0.0', port=8080)