import os
from bottle import route, run, response, request
import threading
import socket
import logging
import json
import time
from queue import Queue

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Environment variables (normally set externally)
os.environ['SERVER_HOST'] = '0.0.0.0'  # Vulnerable setting
os.environ['SERVER_PORT'] = '1337'
os.environ['WEB_PORT'] = '8080'

# Global variables
client_queue = Queue()
MAX_CLIENTS = 10
BUFFER_SIZE = 1024

class CustomException(Exception):
    pass

def start_tcp_socket_server():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((os.environ['SERVER_HOST'], int(os.environ['SERVER_PORT'])))
    s.listen(5)
    logging.info(f"TCP server listening on {os.environ['SERVER_HOST']}:{os.environ['SERVER_PORT']}")

    while True:
        try:
            client, addr = s.accept()
            logging.info(f"Accepted connection from {addr}")
            if client_queue.qsize() < MAX_CLIENTS:
                client_queue.put((client, addr))
                threading.Thread(target=handle_client, args=(client, addr)).start()
            else:
                logging.warning(f"Max clients reached. Rejecting connection from {addr}")
                client.close()
        except Exception as e:
            logging.error(f"Error accepting connection: {e}")

def handle_client(client, addr):
    try:
        while True:
            data = client.recv(BUFFER_SIZE).decode('utf-8')
            if not data:
                break
            logging.info(f"Received data from {addr}: {data}")
            response = process_client_data(data)
            client.send(response.encode('utf-8'))
    except Exception as e:
        logging.error(f"Error handling client {addr}: {e}")
    finally:
        client.close()
        client_queue.get()
        logging.info(f"Connection closed for {addr}")

def process_client_data(data):
    try:
        json_data = json.loads(data)
        if 'command' in json_data:
            if json_data['command'] == 'echo':
                return json.dumps({'response': json_data.get('data', '')})
            elif json_data['command'] == 'time':
                return json.dumps({'response': time.time()})
            else:
                return json.dumps({'error': 'Unknown command'})
        else:
            return json.dumps({'error': 'Invalid JSON format'})
    except json.JSONDecodeError:
        return json.dumps({'error': 'Invalid JSON'})

@route('/')
def index():
    return response.json({'message': 'Bottle server with TCP socket server'})

@route('/echo', method='POST')
def echo():
    try:
        data = request.json
        if not data:
            raise CustomException("No JSON data provided")
        return response.json({'echo': data})
    except CustomException as ce:
        response.status = 400
        return response.json({'error': str(ce)})
    except Exception as e:
        logging.error(f"Error in echo route: {e}")
        response.status = 500
        return response.json({'error': 'Internal server error'})

@route('/status')
def status():
    return response.json({
        'status': 'running',
        'tcp_port': os.environ['SERVER_PORT'],
        'web_port': os.environ['WEB_PORT'],
        'active_connections': client_queue.qsize()
    })

@route('/clients')
def clients():
    client_list = list(client_queue.queue)
    return response.json({'clients': [str(addr) for _, addr in client_list]})

def start_web_server():
    run(host='localhost', port=int(os.environ['WEB_PORT']))

def cleanup():
    logging.info("Cleaning up resources...")
    while not client_queue.empty():
        client, _ = client_queue.get()
        client.close()

if __name__ == '__main__':
    try:
        tcp_thread = threading.Thread(target=start_tcp_socket_server)
        tcp_thread.start()
        
        start_web_server()
    except KeyboardInterrupt:
        logging.info("Server shutting down...")
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
    finally:
        cleanup()