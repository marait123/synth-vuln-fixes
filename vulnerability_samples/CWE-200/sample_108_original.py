import socket
import threading
import sqlite3
from http.server import BaseHTTPRequestHandler, HTTPServer
import json
import base64
import logging
import os
import sys
import argparse
from datetime import datetime

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Global database connection
db_conn = sqlite3.connect('users.db', check_same_thread=False)
db_cursor = db_conn.cursor()

# Create users table
db_cursor.execute('''CREATE TABLE IF NOT EXISTS users
                     (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT, created_at DATETIME)''')
db_conn.commit()

class CustomException(Exception):
    pass

class MyHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        try:
            if self.path == '/users':
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                db_cursor.execute("SELECT id, username, created_at FROM users")
                users = [{"id": row[0], "username": row[1], "created_at": row[2]} for row in db_cursor.fetchall()]
                self.wfile.write(json.dumps(users).encode())
            elif self.path.startswith('/user/'):
                user_id = self.path.split('/')[-1]
                db_cursor.execute("SELECT id, username, created_at FROM users WHERE id=?", (user_id,))
                user = db_cursor.fetchone()
                if user:
                    self.send_response(200)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps({"id": user[0], "username": user[1], "created_at": user[2]}).encode())
                else:
                    self.send_error(404, "User not found")
            else:
                self.send_response(200)
                self.send_header('Content-type', 'text/html')
                self.end_headers()
                self.wfile.write(b"Welcome to the HTTP server!")
        except Exception as e:
            logger.error(f"Error in GET request: {str(e)}")
            self.send_error(500, "Internal Server Error")

    def do_POST(self):
        try:
            if self.path == '/users':
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length)
                user_data = json.loads(post_data.decode())
                
                if not user_data.get('username') or not user_data.get('password'):
                    raise CustomException("Username and password are required")
                
                created_at = datetime.now().isoformat()
                db_cursor.execute("INSERT INTO users (username, password, created_at) VALUES (?, ?, ?)",
                                  (user_data['username'], user_data['password'], created_at))
                db_conn.commit()
                
                self.send_response(201)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"message": "User created successfully", "id": db_cursor.lastrowid}).encode())
            else:
                self.send_error(404, "Not Found")
        except sqlite3.IntegrityError:
            self.send_error(400, "Username already exists")
        except CustomException as ce:
            self.send_error(400, str(ce))
        except Exception as e:
            logger.error(f"Error in POST request: {str(e)}")
            self.send_error(500, "Internal Server Error")

    def do_PUT(self):
        try:
            if self.path.startswith('/user/'):
                user_id = self.path.split('/')[-1]
                content_length = int(self.headers['Content-Length'])
                put_data = self.rfile.read(content_length)
                user_data = json.loads(put_data.decode())
                
                if not user_data.get('username') and not user_data.get('password'):
                    raise CustomException("At least username or password must be provided")
                
                update_query = "UPDATE users SET "
                update_params = []
                if user_data.get('username'):
                    update_query += "username = ?, "
                    update_params.append(user_data['username'])
                if user_data.get('password'):
                    update_query += "password = ?, "
                    update_params.append(user_data['password'])
                update_query = update_query.rstrip(', ') + " WHERE id = ?"
                update_params.append(user_id)
                
                db_cursor.execute(update_query, tuple(update_params))
                db_conn.commit()
                
                if db_cursor.rowcount == 0:
                    self.send_error(404, "User not found")
                else:
                    self.send_response(200)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps({"message": "User updated successfully"}).encode())
            else:
                self.send_error(404, "Not Found")
        except CustomException as ce:
            self.send_error(400, str(ce))
        except Exception as e:
            logger.error(f"Error in PUT request: {str(e)}")
            self.send_error(500, "Internal Server Error")

    def do_DELETE(self):
        try:
            if self.path.startswith('/user/'):
                user_id = self.path.split('/')[-1]
                db_cursor.execute("DELETE FROM users WHERE id = ?", (user_id,))
                db_conn.commit()
                
                if db_cursor.rowcount == 0:
                    self.send_error(404, "User not found")
                else:
                    self.send_response(200)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps({"message": "User deleted successfully"}).encode())
            else:
                self.send_error(404, "Not Found")
        except Exception as e:
            logger.error(f"Error in DELETE request: {str(e)}")
            self.send_error(500, "Internal Server Error")

def handle_client(client_socket):
    try:
        while True:
            data = client_socket.recv(1024)
            if not data:
                break
            client_socket.send(data)
    except Exception as e:
        logger.error(f"Error handling TCP client: {str(e)}")
    finally:
        client_socket.close()

def start_http_and_tcp_server(http_port, tcp_port):
    http_server = HTTPServer(("0.0.0.0", http_port), MyHTTPRequestHandler)
    http_thread = threading.Thread(target=http_server.serve_forever)
    http_thread.start()

    tcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server.bind(("0.0.0.0", tcp_port))
    tcp_server.listen(5)
    logger.info(f"HTTP server started on port {http_port}")
    logger.info(f"TCP server started on port {tcp_port}")

    while True:
        client_socket, addr = tcp_server.accept()
        logger.info(f"New TCP connection from {addr}")
        echo_thread = threading.Thread(target=handle_client, args=(client_socket,))
        echo_thread.start()

def parse_args():
    parser = argparse.ArgumentParser(description="HTTP and TCP Server")
    parser.add_argument("--http-port", type=int, default=8000, help="HTTP server port")
    parser.add_argument("--tcp-port", type=int, default=9000, help="TCP server port")
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()
    try:
        start_http_and_tcp_server(args.http_port, args.tcp_port)
    except KeyboardInterrupt:
        logger.info("Server shutting down...")
        db_conn.close()
        sys.exit(0)