import os
import logging
from django.http import HttpResponse, HttpResponseRedirect, JsonResponse
from django.shortcuts import render, get_object_or_404
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_http_methods
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from .models import BlogPost, Comment
from .forms import UserRegistrationForm, BlogPostForm, CommentForm
from django.views.decorators.csrf import csrf_exempt
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger

logging.basicConfig(filename='blog_app.log', level=logging.INFO)

def register_user(request):
    if request.method == 'POST':
        form = UserRegistrationForm(request.POST)
        if form.is_valid():
            try:
                username = form.cleaned_data['username']
                password = form.cleaned_data['password']
                User.objects.create_user(username=username, password=password)
                logging.info(f"User registered: {username}")
                return HttpResponse("User registered successfully")
            except IntegrityError:
                return HttpResponse("Username already exists", status=400)
        else:
            return HttpResponse("Invalid form data", status=400)
    else:
        form = UserRegistrationForm()
    return render(request, 'register.html', {'form': form})

def user_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)
        if user is not None:
            login(request, user)
            logging.info(f"User logged in: {username}")
            return HttpResponse("Logged in successfully")
        else:
            logging.warning(f"Failed login attempt for username: {username}")
            return HttpResponse("Invalid credentials", status=401)
    return render(request, 'login.html')

@login_required
def user_logout(request):
    logging.info(f"User logged out: {request.user.username}")
    logout(request)
    return HttpResponse("Logged out successfully")

@login_required
@require_http_methods(["POST"])
def add_blog_post(request):
    form = BlogPostForm(request.POST)
    if form.is_valid():
        title = form.cleaned_data['title']
        content = form.cleaned_data['content']
        try:
            post = BlogPost.objects.create(title=title, content=content, author=request.user)
            logging.info(f"Blog post added: {post.id} by {request.user.username}")
            return HttpResponse("Blog post added")
        except ValidationError as e:
            return HttpResponse(str(e), status=400)
    return HttpResponse("Invalid form data", status=400)

def list_blog_posts(request):
    posts_list = BlogPost.objects.all().order_by('-created_at')
    paginator = Paginator(posts_list, 10)
    page = request.GET.get('page')
    try:
        posts = paginator.page(page)
    except PageNotAnInteger:
        posts = paginator.page(1)
    except EmptyPage:
        posts = paginator.page(paginator.num_pages)
    return render(request, 'list_posts.html', {'posts': posts})

def view_blog_post(request, post_id):
    post = get_object_or_404(BlogPost, id=post_id)
    comments = Comment.objects.filter(post=post)
    return render(request, 'view_post.html', {'post': post, 'comments': comments})

@login_required
@require_http_methods(["POST"])
def add_comment(request, post_id):
    form = CommentForm(request.POST)
    if form.is_valid():
        comment_text = form.cleaned_data['comment']
        log_file = f'logs/{post_id}_comments.log'
        os.makedirs(os.path.dirname(log_file), exist_ok=True)
        with open(log_file, 'a') as file:
            file.write(comment_text + '\n')
        Comment.objects.create(post_id=post_id, text=comment_text, author=request.user)
        logging.info(f"Comment added to post {post_id} by {request.user.username}")
        return HttpResponseRedirect(f'/blog/post/{post_id}')
    return HttpResponse("Invalid comment data", status=400)

def search_posts(request):
    query = request.GET.get('q', '')
    posts = BlogPost.objects.filter(title__icontains=query) | BlogPost.objects.filter(content__icontains=query)
    return render(request, 'search_results.html', {'posts': posts, 'query': query})

@login_required
@require_http_methods(["POST"])
def delete_blog_post(request, post_id):
    post = get_object_or_404(BlogPost, id=post_id, author=request.user)
    post.delete()
    logging.info(f"Blog post deleted: {post_id} by {request.user.username}")
    return HttpResponse("Blog post deleted")

@login_required
@require_http_methods(["POST"])
def update_blog_post(request, post_id):
    post = get_object_or_404(BlogPost, id=post_id, author=request.user)
    form = BlogPostForm(request.POST, instance=post)
    if form.is_valid():
        form.save()
        logging.info(f"Blog post updated: {post_id} by {request.user.username}")
        return HttpResponse("Blog post updated")
    return HttpResponse("Invalid form data", status=400)

@csrf_exempt
def api_blog_posts(request):
    if request.method == 'GET':
        posts = BlogPost.objects.all().values('id', 'title', 'author__username', 'created_at')
        return JsonResponse(list(posts), safe=False)
    elif request.method == 'POST':
        if not request.user.is_authenticated:
            return JsonResponse({"error": "Authentication required"}, status=401)
        title = request.POST.get('title')
        content = request.POST.get('content')
        if title and content:
            post = BlogPost.objects.create(title=title, content=content, author=request.user)
            return JsonResponse({"id": post.id, "message": "Blog post created"}, status=201)
        return JsonResponse({"error": "Title and content are required"}, status=400)
    return JsonResponse({"error": "Method not allowed"}, status=405)

def custom_500_error(request):
    return render(request, '500.html', status=500)

def custom_404_error(request, exception):
    return render(request, '404.html', status=404)

# Test cases
def run_tests():
    # Test user registration
    test_user = User.objects.create_user(username='testuser', password='testpass')
    assert test_user is not None, "User registration failed"

    # Test blog post creation
    test_post = BlogPost.objects.create(title='Test Post', content='Test Content', author=test_user)
    assert test_post is not None, "Blog post creation failed"

    # Test comment creation
    test_comment = Comment.objects.create(post=test_post, text='Test Comment', author=test_user)
    assert test_comment is not None, "Comment creation failed"

    # Test blog post retrieval
    retrieved_post = BlogPost.objects.get(id=test_post.id)
    assert retrieved_post.title == 'Test Post', "Blog post retrieval failed"

    print("All tests passed successfully!")

if __name__ == "__main__":
    run_tests()