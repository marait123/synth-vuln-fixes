import logging
from django.contrib.auth.models import User
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
from django.core.exceptions import ValidationError
from django.contrib.auth.password_validation import validate_password
from django.core.mail import send_mail
from django.conf import settings
from django.db import models
from django.utils import timezone
from django.contrib.auth.decorators import login_required
from django.views.decorators.csrf import csrf_exempt
import re

logger = logging.getLogger(__name__)

class PasswordHistory(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='password_history')
    password = models.CharField(max_length=128)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-created_at']

def check_password_strength(password):
    if len(password) < 12:
        raise ValidationError("Password must be at least 12 characters long")
    if not any(char.isdigit() for char in password):
        raise ValidationError("Password must contain at least one number")
    if not any(char.isupper() for char in password):
        raise ValidationError("Password must contain at least one uppercase letter")
    if not any(char.islower() for char in password):
        raise ValidationError("Password must contain at least one lowercase letter")
    if not any(char in "!@#$%^&*()_+-=[]{}|;:,.<>?" for char in password):
        raise ValidationError("Password must contain at least one special character")

def check_password_history(user, new_password):
    for password in user.password_history.all()[:5]:
        if user.check_password(password.password):
            raise ValidationError("New password must not match any of your last 5 passwords")

def send_password_change_notification(user):
    subject = "Password Change Notification"
    message = f"Dear {user.username},\n\nYour password has been successfully changed. If you did not initiate this change, please contact support immediately.\n\nBest regards,\nYour App Team"
    from_email = settings.DEFAULT_FROM_EMAIL
    recipient_list = [user.email]
    send_mail(subject, message, from_email, recipient_list)

@csrf_exempt
@require_http_methods(["POST"])
def api_reset_password_vulnerable(request, user_id):
    try:
        new_password = request.POST.get('new_password', '')  # Vulnerable line
        user = User.objects.get(pk=user_id)
        
        check_password_strength(new_password)
        check_password_history(user, new_password)
        
        if user.last_login and (user.last_login.date() == user.date_joined.date()):
            raise ValidationError("Cannot change password on the day of joining")
        
        validate_password(new_password, user=user)
        user.set_password(new_password)
        user.save()
        
        user.password_history.create(password=new_password)
        if user.password_history.count() > 5:
            user.password_history.earliest('created_at').delete()
        
        send_password_change_notification(user)
        
        logger.info(f"Password changed successfully for user {user.username}")
        return JsonResponse({'status': 'success'})
    except User.DoesNotExist:
        logger.warning(f"Attempt to change password for non-existent user ID: {user_id}")
        return JsonResponse({'error': 'User not found'}, status=404)
    except ValidationError as e:
        logger.warning(f"Password change validation error for user {user_id}: {str(e)}")
        return JsonResponse({'error': str(e)}, status=400)
    except Exception as e:
        logger.error(f"Unexpected error during password change for user {user_id}: {str(e)}")
        return JsonResponse({'error': 'An unexpected error occurred'}, status=500)

@login_required
@require_http_methods(["GET"])
def get_password_history(request):
    try:
        user = request.user
        history = user.password_history.all()[:5]
        data = [{'date': p.created_at.strftime('%Y-%m-%d %H:%M:%S')} for p in history]
        return JsonResponse({'history': data})
    except Exception as e:
        logger.error(f"Error fetching password history for user {user.id}: {str(e)}")
        return JsonResponse({'error': 'An error occurred while fetching password history'}, status=500)

@login_required
@require_http_methods(["POST"])
def change_email(request):
    try:
        new_email = request.POST.get('new_email', '').strip()
        if not re.match(r"[^@]+@[^@]+\.[^@]+", new_email):
            raise ValidationError("Invalid email format")
        
        user = request.user
        user.email = new_email
        user.save()
        
        logger.info(f"Email changed successfully for user {user.username}")
        return JsonResponse({'status': 'success'})
    except ValidationError as e:
        logger.warning(f"Email change validation error for user {request.user.id}: {str(e)}")
        return JsonResponse({'error': str(e)}, status=400)
    except Exception as e:
        logger.error(f"Unexpected error during email change for user {request.user.id}: {str(e)}")
        return JsonResponse({'error': 'An unexpected error occurred'}, status=500)

def run_tests():
    # Simple test cases
    test_user = User.objects.create_user(username='testuser', email='test@example.com', password='OldPassword123!')
    
    # Test 1: Successful password change
    assert api_reset_password_vulnerable(type('MockRequest', (), {'POST': {'new_password': 'NewPassword123!'}}), test_user.id).status_code == 200
    
    # Test 2: Password too short
    assert api_reset_password_vulnerable(type('MockRequest', (), {'POST': {'new_password': 'Short1!'}}), test_user.id).status_code == 400
    
    # Test 3: Password in history
    assert api_reset_password_vulnerable(type('MockRequest', (), {'POST': {'new_password': 'NewPassword123!'}}), test_user.id).status_code == 400
    
    # Test 4: Non-existent user
    assert api_reset_password_vulnerable(type('MockRequest', (), {'POST': {'new_password': 'ValidPassword123!'}}), 9999).status_code == 404
    
    print("All tests passed!")

if __name__ == "__main__":
    run_tests()