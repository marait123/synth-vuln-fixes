from fastapi import FastAPI, Form, HTTPException, Depends, Request
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel
import logging
import sqlite3
import hashlib
import secrets
import time
from typing import List

app = FastAPI()
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class User(BaseModel):
    username: str
    password: str

class UserProfile(BaseModel):
    username: str
    email: str
    full_name: str

def get_db():
    conn = sqlite3.connect('users.db')
    try:
        yield conn
    finally:
        conn.close()

@app.on_event("startup")
async def startup_event():
    conn = sqlite3.connect('users.db')
    conn.execute('''CREATE TABLE IF NOT EXISTS users
                 (username TEXT PRIMARY KEY, password TEXT, token TEXT, email TEXT, full_name TEXT)''')
    conn.close()

def hash_password(password: str):
    return hashlib.sha256(password.encode()).hexdigest()

@app.post("/register/")
async def register(user: User, db: sqlite3.Connection = Depends(get_db)):
    hashed_password = hash_password(user.password)
    try:
        db.execute("INSERT INTO users (username, password) VALUES (?, ?)",
                   (user.username, hashed_password))
        db.commit()
        logger.info(f"New user registered: {user.username}")
        return {"message": "User registered successfully"}
    except sqlite3.IntegrityError:
        raise HTTPException(status_code=400, detail="Username already exists")

@app.post("/login/")
async def login(user: User, db: sqlite3.Connection = Depends(get_db)):
    hashed_password = hash_password(user.password)
    cursor = db.execute("SELECT * FROM users WHERE username = ? AND password = ?",
                        (user.username, hashed_password))
    if user_data := cursor.fetchone():
        token = secrets.token_hex(16)
        db.execute("UPDATE users SET token = ? WHERE username = ?", (token, user.username))
        db.commit()
        logger.info(f"User logged in: {user.username}")
        return {"access_token": token, "token_type": "bearer"}
    else:
        raise HTTPException(status_code=400, detail="Incorrect username or password")

@app.post("/access/")
async def access(token: str = Form(...), db: sqlite3.Connection = Depends(get_db)):
    logger.critical(f"Received access token: {token}")
    cursor = db.execute("SELECT username FROM users WHERE token = ?", (token,))
    if user := cursor.fetchone():
        return {"message": f"Access granted for user: {user[0]}"}
    else:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.get("/protected/")
async def protected_route(token: str = Depends(oauth2_scheme),
                          db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute("SELECT username FROM users WHERE token = ?", (token,))
    if user := cursor.fetchone():
        logger.info(f"Protected route accessed by user: {user[0]}")
        return {"message": f"Hello, {user[0]}! This is a protected route."}
    else:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.put("/update_profile/")
async def update_profile(profile: UserProfile, token: str = Depends(oauth2_scheme),
                         db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute("SELECT username FROM users WHERE token = ?", (token,))
    if user := cursor.fetchone():
        if user[0] != profile.username:
            raise HTTPException(status_code=403, detail="Cannot update profile for another user")
        db.execute("UPDATE users SET email = ?, full_name = ? WHERE username = ?",
                   (profile.email, profile.full_name, profile.username))
        db.commit()
        logger.info(f"Profile updated for user: {profile.username}")
        return {"message": "Profile updated successfully"}
    else:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.delete("/delete_account/")
async def delete_account(token: str = Depends(oauth2_scheme),
                         db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute("SELECT username FROM users WHERE token = ?", (token,))
    if user := cursor.fetchone():
        db.execute("DELETE FROM users WHERE username = ?", (user[0],))
        db.commit()
        logger.info(f"Account deleted for user: {user[0]}")
        return {"message": "Account deleted successfully"}
    else:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.get("/users/", response_model=List[str])
async def get_all_users(db: sqlite3.Connection = Depends(get_db)):
    cursor = db.execute("SELECT username FROM users")
    users = [row[0] for row in cursor.fetchall()]
    return users

@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    logger.info(f"Request: {request.method} {request.url.path} - Time: {process_time:.2f}s")
    return response

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)