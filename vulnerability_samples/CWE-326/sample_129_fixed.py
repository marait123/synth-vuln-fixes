import http.server
import socketserver
import ssl
import logging
import json
import base64

class ConfigManager:
    def __init__(self):
        self.config = {
            'port': 8443,
            'host': 'localhost',
            'log_file': 'server.log',
            'auth_file': 'users.json',
            'cert_file': 'server.crt',
            'key_file': 'server.key'
        }

    def load_config(self, file_path):
        try:
            with open(file_path, 'r') as f:
                self.config.update(json.load(f))
        except FileNotFoundError:
            logging.warning(f"Config file {file_path} not found. Using defaults.")

class AuthManager:
    def __init__(self, auth_file):
        self.users = self.load_users(auth_file)

    def load_users(self, auth_file):
        try:
            with open(auth_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            logging.error(f"Auth file {auth_file} not found.")
            return {}

    def authenticate(self, username, password):
        return username in self.users and self.users[username] == password

class SecureHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def __init__(self, *args, auth_manager=None, **kwargs):
        self.auth_manager = auth_manager
        super().__init__(*args, **kwargs)

    def do_GET(self):
        if self.authenticate():
            super().do_GET()
        else:
            self.send_error(401, "Unauthorized")

    def do_POST(self):
        if self.authenticate():
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(f"Received POST data: {post_data.decode()}".encode())
        else:
            self.send_error(401, "Unauthorized")

    def authenticate(self):
        auth_header = self.headers.get('Authorization')
        if auth_header:
            auth_type, auth_string = auth_header.split()
            if auth_type.lower() == 'basic':
                username, password = base64.b64decode(auth_string).decode().split(':')
                return self.auth_manager.authenticate(username, password)
        return False

    def log_message(self, format, *args):
        logging.info("%s - - [%s] %s\n" % (self.client_address[0], self.log_date_time_string(), format % args))

def run_https_server(config, auth_manager):
    logging.basicConfig(level=logging.INFO, filename=config.config['log_file'], filemode='a',
                        format='%(asctime)s - %(message)s')
    server_address = (config.config['host'], config.config['port'])
    httpd = socketserver.TCPServer(server_address, lambda *args, **kwargs: SecureHTTPRequestHandler(*args, auth_manager=auth_manager, **kwargs))
    
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile=config.config['cert_file'], keyfile=config.config['key_file'])
    httpd.socket = context.wrap_socket(httpd.socket, server_side=True)
    
    logging.info(f"HTTPS Server running on {config.config['host']}:{config.config['port']}")
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        logging.info("Server stopped.")
    finally:
        httpd.server_close()

if __name__ == "__main__":
    config_manager = ConfigManager()
    config_manager.load_config('server_config.json')
    auth_manager = AuthManager(config_manager.config['auth_file'])
    run_https_server(config_manager, auth_manager)