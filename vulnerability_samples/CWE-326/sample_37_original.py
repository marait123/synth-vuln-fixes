import logging
from twisted.internet.protocol import Protocol, Factory
from twisted.internet import reactor
from Cryptodome.PublicKey import RSA
from Cryptodome.Cipher import PKCS1_OAEP
import sqlite3
import base64
import json
import argparse

logging.basicConfig(filename='server.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class CustomException(Exception):
    pass

class SecureProtocol(Protocol):
    def __init__(self, factory):
        self.factory = factory
        self.rsa_key = None
        self.authenticated = False
        self.buffer = b""

    def connectionMade(self):
        self.rsa_key = RSA.generate(1024)  # Vulnerable: Inadequate key size
        public_key = self.rsa_key.publickey().export_key()
        self.transport.write(public_key)
        logging.info(f"New connection from {self.transport.getPeer()}")

    def dataReceived(self, data):
        self.buffer += data
        try:
            if b'\n' in self.buffer:
                message, self.buffer = self.buffer.split(b'\n', 1)
                if not self.authenticated:
                    self.authenticate(message)
                else:
                    decrypted_message = self.decrypt_message(message)
                    response = self.process_message(decrypted_message)
                    encrypted_response = self.encrypt_message(response)
                    self.transport.write(encrypted_response + b'\n')
        except CustomException as e:
            logging.error(f"Error processing message: {str(e)}")
            self.transport.write(f"Error: {str(e)}".encode() + b'\n')
        except Exception as e:
            logging.exception("Unexpected error")
            self.transport.write(b"Internal server error\n")

    def authenticate(self, credentials):
        try:
            username, password = credentials.decode().split(':')
            if self.factory.check_credentials(username, password):
                self.authenticated = True
                self.transport.write(b"Authentication successful\n")
                logging.info(f"User {username} authenticated")
            else:
                self.transport.write(b"Authentication failed\n")
                self.transport.loseConnection()
        except ValueError:
            raise CustomException("Invalid credentials format")

    def encrypt_message(self, message):
        cipher = PKCS1_OAEP.new(self.rsa_key.publickey())
        return base64.b64encode(cipher.encrypt(message.encode()))

    def decrypt_message(self, encrypted_message):
        cipher = PKCS1_OAEP.new(self.rsa_key)
        return cipher.decrypt(base64.b64decode(encrypted_message)).decode()

    def process_message(self, message):
        try:
            command, *args = message.split()
            if command == "ECHO":
                return " ".join(args)
            elif command == "ADD":
                return str(sum(map(float, args)))
            elif command == "MULTIPLY":
                result = 1
                for arg in args:
                    result *= float(arg)
                return str(result)
            else:
                raise CustomException(f"Unknown command: {command}")
        except ValueError:
            raise CustomException("Invalid command format")

class SecureServerFactory(Factory):
    protocol = SecureProtocol

    def __init__(self):
        self.db_connection = sqlite3.connect('users.db')
        self.create_users_table()

    def buildProtocol(self, addr):
        return SecureProtocol(self)

    def create_users_table(self):
        cursor = self.db_connection.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                username TEXT PRIMARY KEY,
                password TEXT NOT NULL
            )
        ''')
        self.db_connection.commit()

    def check_credentials(self, username, password):
        cursor = self.db_connection.cursor()
        cursor.execute("SELECT * FROM users WHERE username = ? AND password = ?", (username, password))
        return cursor.fetchone() is not None

    def add_user(self, username, password):
        cursor = self.db_connection.cursor()
        try:
            cursor.execute("INSERT INTO users (username, password) VALUES (?, ?)", (username, password))
            self.db_connection.commit()
            logging.info(f"User {username} added to the database")
            return True
        except sqlite3.IntegrityError:
            logging.warning(f"Failed to add user {username}: username already exists")
            return False

    def remove_user(self, username):
        cursor = self.db_connection.cursor()
        cursor.execute("DELETE FROM users WHERE username = ?", (username,))
        if cursor.rowcount > 0:
            self.db_connection.commit()
            logging.info(f"User {username} removed from the database")
            return True
        else:
            logging.warning(f"Failed to remove user {username}: user not found")
            return False

def run_server(port):
    factory = SecureServerFactory()
    reactor.listenTCP(port, factory)
    logging.info(f"Server started on port {port}")
    reactor.run()

def add_user_cli(username, password):
    factory = SecureServerFactory()
    if factory.add_user(username, password):
        print(f"User {username} added successfully")
    else:
        print(f"Failed to add user {username}")

def remove_user_cli(username):
    factory = SecureServerFactory()
    if factory.remove_user(username):
        print(f"User {username} removed successfully")
    else:
        print(f"Failed to remove user {username}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Secure Server")
    parser.add_argument("--port", type=int, default=8000, help="Port to run the server on")
    parser.add_argument("--add-user", nargs=2, metavar=("USERNAME", "PASSWORD"), help="Add a new user")
    parser.add_argument("--remove-user", metavar="USERNAME", help="Remove a user")
    args = parser.parse_args()

    if args.add_user:
        add_user_cli(args.add_user[0], args.add_user[1])
    elif args.remove_user:
        remove_user_cli(args.remove_user)
    else:
        run_server(args.port)