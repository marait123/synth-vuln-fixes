import os
import ssl
import socket
import smtplib
import sqlite3
import logging
import hashlib
from email.mime.text import MIMEText
from configparser import ConfigParser
from flask import Flask, request, jsonify
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

app = Flask(__name__)

# Configure logging
logging.basicConfig(filename='app.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Load configuration
config = ConfigParser()
config.read('config.ini')

# Set up rate limiting
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

def send_notification(subject, message):
    sender = config.get('email', 'sender')
    recipient = config.get('email', 'recipient')
    smtp_server = config.get('email', 'smtp_server')
    smtp_port = config.getint('email', 'smtp_port')
    
    msg = MIMEText(message)
    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = recipient
    
    try:
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()
            server.login(config.get('email', 'username'), config.get('email', 'password'))
            server.send_message(msg)
        logging.info(f"Notification sent: {subject}")
    except Exception as e:
        logging.error(f"Failed to send notification: {str(e)}")

def log_request(url, status):
    conn = sqlite3.connect('requests.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS requests
        (id INTEGER PRIMARY KEY, url TEXT, status TEXT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)
    ''')
    cursor.execute('INSERT INTO requests (url, status) VALUES (?, ?)', (url, status))
    conn.commit()
    conn.close()

def get_request_stats():
    conn = sqlite3.connect('requests.db')
    cursor = conn.cursor()
    cursor.execute('SELECT COUNT(*) FROM requests')
    total = cursor.fetchone()[0]
    cursor.execute('SELECT COUNT(*) FROM requests WHERE status LIKE "Success%"')
    successful = cursor.fetchone()[0]
    conn.close()
    return total, successful

@app.route('/req')
@limiter.limit("10/minute")
def make_request():
    try:
        url = request.args.get('url', config.get('target', 'default_url'))
        if not url.startswith(('http://', 'https://')):
            raise ValueError("Invalid URL scheme")

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssock = ssl.wrap_socket(s)  # Vulnerable line
        ssock.connect((config.get('target', 'host'), config.getint('target', 'port')))
        ssock.close()
        
        status = "Success"
        log_request(url, status)
        send_notification("Request Made", f"Request to {url} was successful")
        logging.info(f"Request to {url} successful")
        return jsonify({"status": "success", "message": "Request made successfully"})
    except Exception as e:
        status = f"Error: {str(e)}"
        log_request(url, status)
        send_notification("Request Failed", f"Request to {url} failed: {str(e)}")
        logging.error(f"Request to {url} failed: {str(e)}")
        return jsonify({"status": "error", "message": f"Request failed: {str(e)}"}), 400

@app.route('/stats')
def request_stats():
    total, successful = get_request_stats()
    return jsonify({
        "total_requests": total,
        "successful_requests": successful,
        "success_rate": f"{(successful / total * 100):.2f}%" if total > 0 else "N/A"
    })

@app.route('/health')
def health_check():
    return jsonify({"status": "healthy"})

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

@app.route('/update_config', methods=['POST'])
def update_config():
    if request.json.get('admin_password') != hash_password(config.get('admin', 'password')):
        return jsonify({"status": "error", "message": "Unauthorized"}), 401

    for section in request.json.get('updates', {}):
        if config.has_section(section):
            for key, value in request.json['updates'][section].items():
                config.set(section, key, str(value))

    with open('config.ini', 'w') as configfile:
        config.write(configfile)

    return jsonify({"status": "success", "message": "Configuration updated"})

@app.errorhandler(404)
def not_found(error):
    return jsonify({"status": "error", "message": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    logging.error(f"Internal server error: {str(error)}")
    return jsonify({"status": "error", "message": "Internal server error"}), 500

if __name__ == '__main__':
    app.run(
        host=config.get('app', 'host', fallback='0.0.0.0'),
        port=config.getint('app', 'port', fallback=5000),
        debug=config.getboolean('app', 'debug', fallback=False)
    )