import os
import base64
import logging
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.backends import default_backend
from cryptography.exceptions import InvalidSignature

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class CryptoManager:
    def __init__(self):
        self.private_key = None
        self.public_key = None

    def generate_key_pair(self):
        logging.info("Generating key pair")
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=1024  # Vulnerable: Insufficient key size
        )
        self.public_key = self.private_key.public_key()
        return self.private_key, self.public_key

    def sign_data(self, data):
        if not self.private_key:
            raise ValueError("Private key not generated")
        logging.info("Signing data")
        return self.private_key.sign(
            data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )

    def verify_signature(self, data, signature):
        if not self.public_key:
            raise ValueError("Public key not available")
        try:
            self.public_key.verify(
                signature,
                data,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            logging.info("Signature verified successfully")
            return True
        except InvalidSignature:
            logging.warning("Invalid signature")
            return False

    def encrypt_data(self, data):
        if not self.public_key:
            raise ValueError("Public key not available")
        logging.info("Encrypting data")
        return self.public_key.encrypt(
            data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

    def decrypt_data(self, encrypted_data):
        if not self.private_key:
            raise ValueError("Private key not available")
        logging.info("Decrypting data")
        return self.private_key.decrypt(
            encrypted_data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

class FileManager:
    @staticmethod
    def save_data(data, filename):
        with open(filename, 'wb') as file:
            file.write(data)
        logging.info(f"Data saved to {filename}")

    @staticmethod
    def load_data(filename):
        with open(filename, 'rb') as file:
            data = file.read()
        logging.info(f"Data loaded from {filename}")
        return data

def main():
    crypto_manager = CryptoManager()
    file_manager = FileManager()

    try:
        private_key, public_key = crypto_manager.generate_key_pair()

        # Example data
        original_data = b"This is sensitive information"

        # Sign the data
        signature = crypto_manager.sign_data(original_data)

        # Verify the signature
        if crypto_manager.verify_signature(original_data, signature):
            print("Signature verified successfully")
        else:
            print("Signature verification failed")

        # Encrypt the data
        encrypted_data = crypto_manager.encrypt_data(original_data)

        # Save encrypted data to file
        file_manager.save_data(encrypted_data, "encrypted_data.bin")

        # Load encrypted data from file
        loaded_encrypted_data = file_manager.load_data("encrypted_data.bin")

        # Decrypt the loaded data
        decrypted_data = crypto_manager.decrypt_data(loaded_encrypted_data)

        print(f"Original data: {original_data}")
        print(f"Decrypted data: {decrypted_data}")
        print(f"Signature: {base64.b64encode(signature).decode()}")

    except Exception as e:
        logging.error(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()

# Test cases
def run_tests():
    crypto_manager = CryptoManager()
    file_manager = FileManager()

    # Test key generation
    private_key, public_key = crypto_manager.generate_key_pair()
    assert private_key is not None
    assert public_key is not None

    # Test encryption and decryption
    test_data = b"Test data for encryption"
    encrypted = crypto_manager.encrypt_data(test_data)
    decrypted = crypto_manager.decrypt_data(encrypted)
    assert test_data == decrypted

    # Test signature and verification
    signature = crypto_manager.sign_data(test_data)
    assert crypto_manager.verify_signature(test_data, signature)

    # Test file operations
    file_manager.save_data(encrypted, "test_encrypted.bin")
    loaded_data = file_manager.load_data("test_encrypted.bin")
    assert encrypted == loaded_data

    print("All tests passed successfully")

if __name__ == "__main__":
    run_tests()