import os
import base64
import logging
import sqlite3
from flask import Flask, jsonify, request, session, render_template
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from werkzeug.security import generate_password_hash, check_password_hash
from functools import wraps

app = Flask(__name__)
app.secret_key = os.urandom(24)
logging.basicConfig(level=logging.INFO)

def get_db_connection():
    conn = sqlite3.connect('database.db')
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    conn = get_db_connection()
    conn.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT)')
    conn.execute('CREATE TABLE IF NOT EXISTS messages (id INTEGER PRIMARY KEY, user_id INTEGER, encrypted_message TEXT)')
    conn.close()

init_db()

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({"error": "User not logged in"}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/register', methods=['POST'])
def register():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    if not username or not password:
        return jsonify({"error": "Username and password are required"}), 400
    
    hashed_password = generate_password_hash(password)
    conn = get_db_connection()
    try:
        conn.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))
        conn.commit()
        logging.info(f"User registered: {username}")
        return jsonify({"message": "User registered successfully"}), 201
    except sqlite3.IntegrityError:
        return jsonify({"error": "Username already exists"}), 400
    finally:
        conn.close()

@app.route('/login', methods=['POST'])
def login():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    conn = get_db_connection()
    user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()
    conn.close()
    
    if user and check_password_hash(user['password'], password):
        session['user_id'] = user['id']
        logging.info(f"User logged in: {username}")
        return jsonify({"message": "Login successful"}), 200
    return jsonify({"error": "Invalid credentials"}), 401

@app.route('/logout', methods=['POST'])
@login_required
def logout():
    session.pop('user_id', None)
    return jsonify({"message": "Logged out successfully"}), 200

@app.route('/encrypt_message', methods=['POST'])
@login_required
def encrypt_message():
    data = request.json
    message = data.get('message')
    if not message:
        return jsonify({"error": "Message is required"}), 400
    
    key = RSA.generate(1024)  # Vulnerable: Using 1024-bit key
    public_key = key.publickey()
    cipher = PKCS1_OAEP.new(public_key)
    encrypted_message = cipher.encrypt(message.encode('utf-8'))
    encoded_message = base64.b64encode(encrypted_message).decode('utf-8')
    
    conn = get_db_connection()
    conn.execute('INSERT INTO messages (user_id, encrypted_message) VALUES (?, ?)', (session['user_id'], encoded_message))
    conn.commit()
    conn.close()
    
    logging.info(f"Message encrypted for user_id: {session['user_id']}")
    return jsonify({"message": "Message encrypted and stored successfully"}), 200

@app.route('/get_messages', methods=['GET'])
@login_required
def get_messages():
    conn = get_db_connection()
    messages = conn.execute('SELECT encrypted_message FROM messages WHERE user_id = ?', (session['user_id'],)).fetchall()
    conn.close()
    
    return jsonify({"messages": [msg['encrypted_message'] for msg in messages]}), 200

@app.route('/delete_message/<int:message_id>', methods=['DELETE'])
@login_required
def delete_message(message_id):
    conn = get_db_connection()
    conn.execute('DELETE FROM messages WHERE id = ? AND user_id = ?', (message_id, session['user_id']))
    conn.commit()
    conn.close()
    logging.info(f"Message deleted: {message_id} for user_id: {session['user_id']}")
    return jsonify({"message": "Message deleted successfully"}), 200

@app.route('/update_password', methods=['PUT'])
@login_required
def update_password():
    data = request.json
    old_password = data.get('old_password')
    new_password = data.get('new_password')
    if not old_password or not new_password:
        return jsonify({"error": "Old and new passwords are required"}), 400
    
    conn = get_db_connection()
    user = conn.execute('SELECT * FROM users WHERE id = ?', (session['user_id'],)).fetchone()
    
    if not check_password_hash(user['password'], old_password):
        conn.close()
        return jsonify({"error": "Invalid old password"}), 400
    
    hashed_new_password = generate_password_hash(new_password)
    conn.execute('UPDATE users SET password = ? WHERE id = ?', (hashed_new_password, session['user_id']))
    conn.commit()
    conn.close()
    
    logging.info(f"Password updated for user_id: {session['user_id']}")
    return jsonify({"message": "Password updated successfully"}), 200

def sanitize_input(input_string):
    return ''.join(char for char in input_string if char.isalnum() or char.isspace())

@app.route('/search_messages', methods=['GET'])
@login_required
def search_messages():
    search_term = sanitize_input(request.args.get('term', ''))
    conn = get_db_connection()
    messages = conn.execute('SELECT encrypted_message FROM messages WHERE user_id = ? AND encrypted_message LIKE ?', 
                            (session['user_id'], f'%{search_term}%')).fetchall()
    conn.close()
    return jsonify({"messages": [msg['encrypted_message'] for msg in messages]}), 200

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    logging.error(f"Internal server error: {error}")
    return jsonify({"error": "Internal server error"}), 500

if __name__ == '__main__':
    app.run(debug=True)