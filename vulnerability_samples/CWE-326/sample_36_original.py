import os
import logging
from Cryptodome.PublicKey import RSA
from Cryptodome.Cipher import PKCS1_OAEP
from Cryptodome.Random import get_random_bytes
from Cryptodome.Hash import SHA256
from base64 import b64encode, b64decode

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class CryptoException(Exception):
    pass

def generate_key_pair(key_size=1024):
    try:
        key = RSA.generate(key_size)
        private_key = key.export_key()
        public_key = key.publickey().export_key()
        logger.info(f"Generated RSA key pair with size {key_size}")
        return private_key, public_key
    except Exception as e:
        logger.error(f"Error generating key pair: {str(e)}")
        raise CryptoException("Failed to generate key pair")

def save_key(key, filename):
    try:
        with open(filename, 'wb') as key_file:
            key_file.write(key)
        logger.info(f"Saved key to {filename}")
    except IOError as e:
        logger.error(f"Error saving key to {filename}: {str(e)}")
        raise CryptoException(f"Failed to save key to {filename}")

def load_key(filename):
    try:
        with open(filename, 'rb') as key_file:
            key = key_file.read()
        logger.info(f"Loaded key from {filename}")
        return key
    except IOError as e:
        logger.error(f"Error loading key from {filename}: {str(e)}")
        raise CryptoException(f"Failed to load key from {filename}")

def encrypt_file(input_file, output_file, public_key):
    try:
        key = RSA.import_key(public_key)
        cipher = PKCS1_OAEP.new(key, hashAlgo=SHA256)

        with open(input_file, 'rb') as file:
            data = file.read()

        chunk_size = 86  # Maximum size for 1024-bit key
        encrypted_data = b''
        for i in range(0, len(data), chunk_size):
            chunk = data[i:i+chunk_size]
            encrypted_chunk = cipher.encrypt(chunk)
            encrypted_data += encrypted_chunk

        with open(output_file, 'wb') as file:
            file.write(encrypted_data)

        logger.info(f"Encrypted {input_file} to {output_file}")
    except Exception as e:
        logger.error(f"Error encrypting file: {str(e)}")
        raise CryptoException("Failed to encrypt file")

def decrypt_file(input_file, output_file, private_key):
    try:
        key = RSA.import_key(private_key)
        cipher = PKCS1_OAEP.new(key, hashAlgo=SHA256)

        with open(input_file, 'rb') as file:
            encrypted_data = file.read()

        chunk_size = 128  # Size of encrypted chunk for 1024-bit key
        decrypted_data = b''
        for i in range(0, len(encrypted_data), chunk_size):
            chunk = encrypted_data[i:i+chunk_size]
            decrypted_chunk = cipher.decrypt(chunk)
            decrypted_data += decrypted_chunk

        with open(output_file, 'wb') as file:
            file.write(decrypted_data)

        logger.info(f"Decrypted {input_file} to {output_file}")
    except Exception as e:
        logger.error(f"Error decrypting file: {str(e)}")
        raise CryptoException("Failed to decrypt file")

def encrypt_string(message, public_key):
    try:
        key = RSA.import_key(public_key)
        cipher = PKCS1_OAEP.new(key, hashAlgo=SHA256)
        encrypted_message = cipher.encrypt(message.encode())
        return b64encode(encrypted_message).decode()
    except Exception as e:
        logger.error(f"Error encrypting string: {str(e)}")
        raise CryptoException("Failed to encrypt string")

def decrypt_string(encrypted_message, private_key):
    try:
        key = RSA.import_key(private_key)
        cipher = PKCS1_OAEP.new(key, hashAlgo=SHA256)
        decrypted_message = cipher.decrypt(b64decode(encrypted_message))
        return decrypted_message.decode()
    except Exception as e:
        logger.error(f"Error decrypting string: {str(e)}")
        raise CryptoException("Failed to decrypt string")

def main():
    try:
        private_key, public_key = generate_key_pair()
        save_key(private_key, 'private_key.pem')
        save_key(public_key, 'public_key.pem')

        with open('original.txt', 'w') as file:
            file.write("This is a secret message.")

        encrypt_file('original.txt', 'encrypted.bin', public_key)
        decrypt_file('encrypted.bin', 'decrypted.txt', private_key)

        # String encryption/decryption demo
        message = "Hello, World!"
        encrypted = encrypt_string(message, public_key)
        decrypted = decrypt_string(encrypted, private_key)
        print(f"Original: {message}")
        print(f"Encrypted: {encrypted}")
        print(f"Decrypted: {decrypted}")

        print("File and string encryption/decryption completed successfully.")
    except CryptoException as e:
        print(f"Crypto operation failed: {str(e)}")
    except Exception as e:
        print(f"An unexpected error occurred: {str(e)}")

if __name__ == "__main__":
    main()

# Test cases
def run_tests():
    try:
        # Test key generation
        private_key, public_key = generate_key_pair()
        assert private_key and public_key, "Key generation failed"

        # Test file encryption/decryption
        with open('test.txt', 'w') as f:
            f.write("Test message")
        encrypt_file('test.txt', 'test_encrypted.bin', public_key)
        decrypt_file('test_encrypted.bin', 'test_decrypted.txt', private_key)
        with open('test_decrypted.txt', 'r') as f:
            assert f.read() == "Test message", "File encryption/decryption failed"

        # Test string encryption/decryption
        test_message = "Test string"
        encrypted = encrypt_string(test_message, public_key)
        decrypted = decrypt_string(encrypted, private_key)
        assert decrypted == test_message, "String encryption/decryption failed"

        print("All tests passed successfully!")
    except Exception as e:
        print(f"Test failed: {str(e)}")

# Uncomment the following line to run tests
# run_tests()