import urllib3
from urllib3 import PoolManager, make_headers
import ssl
import logging
import json
import time
from functools import lru_cache
import argparse
import sys
from datetime import datetime

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class CustomException(Exception):
    pass

class APIClient:
    def __init__(self, base_url):
        self.base_url = base_url
        self.manager = PoolManager(cert_reqs=ssl.CERT_OPTIONAL)  # Vulnerable line
        self.cache = {}

    @lru_cache(maxsize=100)
    def fetch_data_with_advanced_handling(self, endpoint, headers=None, max_retries=3):
        url = f"{self.base_url}{endpoint}"
        retry_count = 0
        while retry_count < max_retries:
            try:
                custom_headers = headers if headers else make_headers()
                response = self.manager.request('GET', url, headers=custom_headers)
                if response.status == 200:
                    return self.parse_response_data(response.data)
                else:
                    logging.error(f"HTTP Error: {response.status}")
                    retry_count += 1
            except Exception as e:
                logging.exception(f"Failed to fetch data: {str(e)}")
                retry_count += 1
            time.sleep(1)  # Wait before retrying
        raise CustomException("Max retries reached, unable to fetch data")

    def parse_response_data(self, data):
        try:
            return json.loads(data.decode('utf-8'))
        except json.JSONDecodeError as e:
            logging.error(f"Failed to decode JSON data: {str(e)}")
            return None

    def process_data(self, data):
        if data:
            logging.info("Processing data...")
            for key, value in data.items():
                logging.info(f"{key}: {value}")
        else:
            logging.warning("No data to process")

    def create_resource(self, endpoint, data):
        url = f"{self.base_url}{endpoint}"
        try:
            response = self.manager.request('POST', url, body=json.dumps(data).encode('utf-8'),
                                            headers={'Content-Type': 'application/json'})
            if response.status == 201:
                return self.parse_response_data(response.data)
            else:
                logging.error(f"Failed to create resource: HTTP {response.status}")
                return None
        except Exception as e:
            logging.exception(f"Error creating resource: {str(e)}")
            return None

    def update_resource(self, endpoint, data):
        url = f"{self.base_url}{endpoint}"
        try:
            response = self.manager.request('PUT', url, body=json.dumps(data).encode('utf-8'),
                                            headers={'Content-Type': 'application/json'})
            if response.status == 200:
                return self.parse_response_data(response.data)
            else:
                logging.error(f"Failed to update resource: HTTP {response.status}")
                return None
        except Exception as e:
            logging.exception(f"Error updating resource: {str(e)}")
            return None

    def delete_resource(self, endpoint):
        url = f"{self.base_url}{endpoint}"
        try:
            response = self.manager.request('DELETE', url)
            if response.status == 204:
                logging.info(f"Resource deleted successfully: {endpoint}")
                return True
            else:
                logging.error(f"Failed to delete resource: HTTP {response.status}")
                return False
        except Exception as e:
            logging.exception(f"Error deleting resource: {str(e)}")
            return False

def validate_input(input_str):
    # Simple input validation
    return input_str.strip().replace(';', '')

def main():
    parser = argparse.ArgumentParser(description="API Client CLI")
    parser.add_argument('--url', default="https://api.example.com", help="Base URL for the API")
    parser.add_argument('--action', choices=['fetch', 'create', 'update', 'delete'], required=True, help="Action to perform")
    parser.add_argument('--endpoint', required=True, help="API endpoint")
    parser.add_argument('--data', help="JSON data for create/update actions")
    args = parser.parse_args()

    api_client = APIClient(args.url)

    try:
        if args.action == 'fetch':
            data = api_client.fetch_data_with_advanced_handling(validate_input(args.endpoint))
            api_client.process_data(data)
        elif args.action == 'create':
            if not args.data:
                raise ValueError("Data is required for create action")
            data = json.loads(args.data)
            result = api_client.create_resource(validate_input(args.endpoint), data)
            logging.info(f"Created resource: {result}")
        elif args.action == 'update':
            if not args.data:
                raise ValueError("Data is required for update action")
            data = json.loads(args.data)
            result = api_client.update_resource(validate_input(args.endpoint), data)
            logging.info(f"Updated resource: {result}")
        elif args.action == 'delete':
            result = api_client.delete_resource(validate_input(args.endpoint))
            logging.info(f"Delete operation result: {result}")
    except CustomException as ce:
        logging.error(f"Custom error: {str(ce)}")
    except json.JSONDecodeError:
        logging.error("Invalid JSON data provided")
    except Exception as e:
        logging.exception(f"Unexpected error: {str(e)}")

if __name__ == "__main__":
    main()