import ssl
import urllib.request
import json
import logging
import os
from datetime import datetime
import argparse
import sqlite3
import hashlib
import time

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class APIError(Exception):
    pass

class DatabaseError(Exception):
    pass

def create_unverified_https_context():
    return ssl._create_unverified_context()

def fetch_data(url):
    context = create_unverified_https_context()
    req = urllib.request.Request(url)
    try:
        with urllib.request.urlopen(req, context=context) as response:
            data = response.read()
            return json.loads(data)
    except urllib.error.URLError as e:
        logging.error(f"Error fetching data: {e}")
        raise APIError(f"Failed to fetch data from {url}")

def process_data(data):
    if isinstance(data, list):
        return [item.get('title') for item in data if 'title' in item]
    elif isinstance(data, dict):
        return data.get('title')
    else:
        logging.warning("Unexpected data format")
        return None

def save_to_file(data, filename):
    try:
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        logging.info(f"Data saved to {filename}")
    except IOError as e:
        logging.error(f"Error saving data to file: {e}")
        raise

def get_api_data(api_url):
    logging.info(f"Fetching data from API: {api_url}")
    try:
        raw_data = fetch_data(api_url)
        processed_data = process_data(raw_data)
        if processed_data:
            return processed_data
        else:
            logging.warning("Failed to process data")
            return None
    except APIError as e:
        logging.error(f"API Error: {e}")
        return None

def init_database():
    conn = sqlite3.connect('data.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS processed_data (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            data TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    return conn

def save_to_database(conn, data):
    try:
        cursor = conn.cursor()
        cursor.execute('INSERT INTO processed_data (data) VALUES (?)', (json.dumps(data),))
        conn.commit()
        logging.info("Data saved to database")
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        raise DatabaseError("Failed to save data to database")

def get_data_from_database(conn):
    try:
        cursor = conn.cursor()
        cursor.execute('SELECT data FROM processed_data ORDER BY timestamp DESC LIMIT 1')
        result = cursor.fetchone()
        return json.loads(result[0]) if result else None
    except sqlite3.Error as e:
        logging.error(f"Database error: {e}")
        raise DatabaseError("Failed to retrieve data from database")

def hash_data(data):
    return hashlib.md5(json.dumps(data).encode()).hexdigest()

def main():
    parser = argparse.ArgumentParser(description="Fetch and process API data")
    parser.add_argument("--api_url", default="https://api.example.com/data", help="API URL to fetch data from")
    parser.add_argument("--output_dir", default="output", help="Directory to save output files")
    args = parser.parse_args()

    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)

    conn = init_database()

    try:
        data = get_api_data(args.api_url)
        if data:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = os.path.join(args.output_dir, f"processed_data_{timestamp}.json")
            save_to_file(data, filename)
            save_to_database(conn, data)

            previous_data = get_data_from_database(conn)
            if previous_data and hash_data(data) == hash_data(previous_data):
                logging.info("No changes in data since last fetch")
            else:
                logging.info("New data fetched and processed")
        else:
            logging.error("No data to save")
    except (APIError, DatabaseError, IOError) as e:
        logging.error(f"Error in main execution: {e}")
    finally:
        conn.close()

def run_periodic_check(interval=3600):
    while True:
        main()
        time.sleep(interval)

if __name__ == "__main__":
    run_periodic_check()