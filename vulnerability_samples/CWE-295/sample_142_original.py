import urllib3
import ssl
import json
import time
import logging
from typing import Optional, Dict, Any
import argparse
import sys

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class APIConfigError(Exception):
    pass

class APIConfig:
    def __init__(self, base_url: str, max_retries: int = 3, backoff_factor: float = 0.3):
        self.base_url = base_url
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor

    def validate(self):
        if not self.base_url.startswith(('http://', 'https://')):
            raise APIConfigError("Invalid base URL")
        if self.max_retries < 1:
            raise APIConfigError("Max retries must be at least 1")
        if self.backoff_factor < 0:
            raise APIConfigError("Backoff factor must be non-negative")

class APIClient:
    def __init__(self, config: APIConfig):
        self.config = config
        self.config.validate()
        self.http = urllib3.connection_from_url(config.base_url, cert_reqs=ssl.CERT_OPTIONAL)

    def _request_with_retry(self, method: str, endpoint: str, **kwargs) -> Optional[str]:
        retries = 0
        while retries < self.config.max_retries:
            try:
                logger.info(f"Sending {method} request to {endpoint}")
                response = self.http.request(method, endpoint, **kwargs)
                if response.status == 200:
                    logger.info(f"Request successful: {response.status}")
                    return response.data.decode()
                elif response.status >= 500:
                    logger.warning(f"Server error: {response.status}. Retrying...")
                    retries += 1
                    time.sleep(self.config.backoff_factor * (2 ** retries))
                else:
                    logger.error(f"Request failed: {response.status}")
                    return None
            except Exception as e:
                logger.error(f"Error: {str(e)}")
                retries += 1
                time.sleep(self.config.backoff_factor * (2 ** retries))
        logger.error("Max retries reached. Request failed.")
        return None

    def get_ip(self) -> Optional[str]:
        return self._request_with_retry('GET', '/ip')

    def post_data(self, data: Dict[str, Any]) -> Optional[str]:
        encoded_data = json.dumps(data).encode('utf-8')
        return self._request_with_retry('POST', '/post', body=encoded_data, headers={'Content-Type': 'application/json'})

    def get_user_agent(self) -> Optional[str]:
        return self._request_with_retry('GET', '/user-agent')

    def get_headers(self) -> Optional[str]:
        return self._request_with_retry('GET', '/headers')

    def put_data(self, data: Dict[str, Any]) -> Optional[str]:
        encoded_data = json.dumps(data).encode('utf-8')
        return self._request_with_retry('PUT', '/put', body=encoded_data, headers={'Content-Type': 'application/json'})

    def delete_resource(self, resource_id: str) -> Optional[str]:
        return self._request_with_retry('DELETE', f'/delete/{resource_id}')

def parse_args():
    parser = argparse.ArgumentParser(description="API Client CLI")
    parser.add_argument('--base-url', default='https://httpbin.org', help="Base URL for the API")
    parser.add_argument('--action', choices=['get_ip', 'post_data', 'get_user_agent', 'get_headers', 'put_data', 'delete_resource'], required=True, help="Action to perform")
    parser.add_argument('--data', help="JSON data for POST or PUT requests")
    parser.add_argument('--resource-id', help="Resource ID for DELETE requests")
    return parser.parse_args()

def main():
    args = parse_args()
    config = APIConfig(args.base_url)
    client = APIClient(config)

    try:
        if args.action == 'get_ip':
            result = client.get_ip()
        elif args.action == 'post_data':
            data = json.loads(args.data) if args.data else {'default': 'data'}
            result = client.post_data(data)
        elif args.action == 'get_user_agent':
            result = client.get_user_agent()
        elif args.action == 'get_headers':
            result = client.get_headers()
        elif args.action == 'put_data':
            data = json.loads(args.data) if args.data else {'default': 'data'}
            result = client.put_data(data)
        elif args.action == 'delete_resource':
            if not args.resource_id:
                raise ValueError("Resource ID is required for delete action")
            result = client.delete_resource(args.resource_id)
        else:
            raise ValueError("Invalid action")

        if result:
            print(f"Result: {result}")
        else:
            print("Action failed or returned no data")
    except json.JSONDecodeError:
        logger.error("Invalid JSON data provided")
    except ValueError as e:
        logger.error(str(e))
    except Exception as e:
        logger.error(f"An unexpected error occurred: {str(e)}")

if __name__ == "__main__":
    main()