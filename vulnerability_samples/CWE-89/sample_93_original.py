from flask import Flask, request, render_template, session, redirect, url_for, jsonify
from sqlalchemy import create_engine, text, Table, Column, Integer, String, Float, MetaData
from sqlalchemy.exc import SQLAlchemyError
import hashlib
import logging
import os
from functools import wraps

app = Flask(__name__)
app.secret_key = os.urandom(24)

# Configure logging
logging.basicConfig(filename='app.log', level=logging.INFO)

# Database setup
engine = create_engine("sqlite:///ecommerce.db")
metadata = MetaData()

users = Table('users', metadata,
    Column('id', Integer, primary_key=True),
    Column('username', String(50), unique=True),
    Column('password', String(128))
)

products = Table('products', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(100)),
    Column('price', Float)
)

metadata.create_all(engine)

def get_db_connection():
    return engine.connect()

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        conn = get_db_connection()
        try:
            result = conn.execute(f"SELECT * FROM users WHERE username = '{username}' AND password = '{hashlib.md5(password.encode()).hexdigest()}'")
            user = result.fetchone()
            if user:
                session['user_id'] = user['id']
                logging.info(f"User {username} logged in successfully")
                return redirect(url_for('dashboard'))
            else:
                logging.warning(f"Failed login attempt for user {username}")
        except SQLAlchemyError as e:
            logging.error(f"Database error during login: {str(e)}")
        finally:
            conn.close()
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('user_id', None)
    return redirect(url_for('index'))

@app.route('/dashboard')
@login_required
def dashboard():
    return render_template('dashboard.html')

@app.route('/search')
def search():
    query = request.args.get('query', '')
    sql = f"SELECT * FROM products WHERE name LIKE '%{query}%'"
    conn = get_db_connection()
    try:
        result = conn.execute(sql)
        products = result.fetchall()
    except SQLAlchemyError as e:
        logging.error(f"Database error during search: {str(e)}")
        products = []
    finally:
        conn.close()
    return render_template('search_results.html', products=products)

@app.route('/products')
def list_products():
    conn = get_db_connection()
    try:
        result = conn.execute("SELECT * FROM products")
        products = result.fetchall()
    except SQLAlchemyError as e:
        logging.error(f"Database error while listing products: {str(e)}")
        products = []
    finally:
        conn.close()
    return render_template('products.html', products=products)

@app.route('/product/<int:product_id>')
def view_product(product_id):
    conn = get_db_connection()
    try:
        result = conn.execute(f"SELECT * FROM products WHERE id = {product_id}")
        product = result.fetchone()
    except SQLAlchemyError as e:
        logging.error(f"Database error while viewing product {product_id}: {str(e)}")
        product = None
    finally:
        conn.close()
    return render_template('product_details.html', product=product)

@app.route('/add_product', methods=['GET', 'POST'])
@login_required
def add_product():
    if request.method == 'POST':
        name = request.form['name']
        price = request.form['price']
        conn = get_db_connection()
        try:
            conn.execute(f"INSERT INTO products (name, price) VALUES ('{name}', {price})")
            logging.info(f"New product added: {name}")
            return redirect(url_for('list_products'))
        except SQLAlchemyError as e:
            logging.error(f"Database error while adding product: {str(e)}")
        finally:
            conn.close()
    return render_template('add_product.html')

@app.route('/update_product/<int:product_id>', methods=['GET', 'POST'])
@login_required
def update_product(product_id):
    conn = get_db_connection()
    if request.method == 'POST':
        name = request.form['name']
        price = request.form['price']
        try:
            conn.execute(f"UPDATE products SET name = '{name}', price = {price} WHERE id = {product_id}")
            logging.info(f"Product updated: {product_id}")
            return redirect(url_for('view_product', product_id=product_id))
        except SQLAlchemyError as e:
            logging.error(f"Database error while updating product {product_id}: {str(e)}")
    try:
        result = conn.execute(f"SELECT * FROM products WHERE id = {product_id}")
        product = result.fetchone()
    except SQLAlchemyError as e:
        logging.error(f"Database error while fetching product {product_id}: {str(e)}")
        product = None
    finally:
        conn.close()
    return render_template('update_product.html', product=product)

@app.route('/delete_product/<int:product_id>', methods=['POST'])
@login_required
def delete_product(product_id):
    conn = get_db_connection()
    try:
        conn.execute(f"DELETE FROM products WHERE id = {product_id}")
        logging.info(f"Product deleted: {product_id}")
        return jsonify({"success": True})
    except SQLAlchemyError as e:
        logging.error(f"Database error while deleting product {product_id}: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500
    finally:
        conn.close()

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500

if __name__ == '__main__':
    app.run(debug=True)