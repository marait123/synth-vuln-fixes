import sqlite3
import logging
from flask import Flask, request, jsonify, session
from werkzeug.security import generate_password_hash, check_password_hash
import os
import json

app = Flask(__name__)
app.secret_key = os.urandom(24)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def init_db():
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS books
                      (id INTEGER PRIMARY KEY, title TEXT, author TEXT, year INTEGER)''')
    cursor.execute('''CREATE TABLE IF NOT EXISTS users
                      (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT)''')
    conn.commit()
    conn.close()

@app.route('/register', methods=['POST'])
def register():
    username = request.json.get('username')
    password = request.json.get('password')
    if not username or not password:
        return jsonify({"message": "Username and password are required"}), 400
    hashed_password = generate_password_hash(password)
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO users (username, password) VALUES (?, ?)", (username, hashed_password))
        conn.commit()
        logging.info(f"New user registered: {username}")
        return jsonify({"message": "User registered successfully"}), 201
    except sqlite3.IntegrityError:
        return jsonify({"message": "Username already exists"}), 409
    finally:
        conn.close()

@app.route('/login', methods=['POST'])
def login():
    username = request.json.get('username')
    password = request.json.get('password')
    if not username or not password:
        return jsonify({"message": "Username and password are required"}), 400
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
    user = cursor.fetchone()
    conn.close()
    if user and check_password_hash(user[2], password):
        session['user_id'] = user[0]
        logging.info(f"User logged in: {username}")
        return jsonify({"message": "Login successful"}), 200
    return jsonify({"message": "Invalid credentials"}), 401

@app.route('/logout', methods=['POST'])
def logout():
    if 'user_id' in session:
        user_id = session.pop('user_id')
        logging.info(f"User logged out: {user_id}")
        return jsonify({"message": "Logout successful"}), 200
    return jsonify({"message": "No user logged in"}), 400

@app.route('/get_books', methods=['GET'])
def get_books():
    if 'user_id' not in session:
        return jsonify({"message": "Unauthorized"}), 401
    author = request.args.get('author')
    year = request.args.get('year')
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    query = "SELECT * FROM books WHERE author = '{}' AND year = {}".format(author, year)
    cursor.execute(query)
    books = cursor.fetchall()
    conn.close()
    return jsonify([{"id": book[0], "title": book[1], "author": book[2], "year": book[3]} for book in books])

@app.route('/add_book', methods=['POST'])
def add_book():
    if 'user_id' not in session:
        return jsonify({"message": "Unauthorized"}), 401
    title = request.json.get('title')
    author = request.json.get('author')
    year = request.json.get('year')
    if not title or not author or not year:
        return jsonify({"message": "Title, author, and year are required"}), 400
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute("INSERT INTO books (title, author, year) VALUES (?, ?, ?)", (title, author, year))
    conn.commit()
    book_id = cursor.lastrowid
    conn.close()
    logging.info(f"New book added: {title} by {author}")
    return jsonify({"message": "Book added successfully", "id": book_id}), 201

@app.route('/get_book/<int:book_id>', methods=['GET'])
def get_book(book_id):
    if 'user_id' not in session:
        return jsonify({"message": "Unauthorized"}), 401
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM books WHERE id = ?", (book_id,))
    book = cursor.fetchone()
    conn.close()
    if book:
        return jsonify({"id": book[0], "title": book[1], "author": book[2], "year": book[3]})
    return jsonify({"message": "Book not found"}), 404

@app.route('/update_book/<int:book_id>', methods=['PUT'])
def update_book(book_id):
    if 'user_id' not in session:
        return jsonify({"message": "Unauthorized"}), 401
    title = request.json.get('title')
    author = request.json.get('author')
    year = request.json.get('year')
    if not title and not author and not year:
        return jsonify({"message": "No update data provided"}), 400
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    update_query = "UPDATE books SET "
    update_data = []
    if title:
        update_query += "title = ?, "
        update_data.append(title)
    if author:
        update_query += "author = ?, "
        update_data.append(author)
    if year:
        update_query += "year = ?, "
        update_data.append(year)
    update_query = update_query.rstrip(", ") + " WHERE id = ?"
    update_data.append(book_id)
    cursor.execute(update_query, tuple(update_data))
    conn.commit()
    if cursor.rowcount == 0:
        conn.close()
        return jsonify({"message": "Book not found"}), 404
    conn.close()
    logging.info(f"Book updated: {book_id}")
    return jsonify({"message": "Book updated successfully"}), 200

@app.route('/delete_book/<int:book_id>', methods=['DELETE'])
def delete_book(book_id):
    if 'user_id' not in session:
        return jsonify({"message": "Unauthorized"}), 401
    conn = sqlite3.connect('library.db')
    cursor = conn.cursor()
    cursor.execute("DELETE FROM books WHERE id = ?", (book_id,))
    conn.commit()
    if cursor.rowcount == 0:
        conn.close()
        return jsonify({"message": "Book not found"}), 404
    conn.close()
    logging.info(f"Book deleted: {book_id}")
    return jsonify({"message": "Book deleted successfully"}), 200

@app.errorhandler(Exception)
def handle_error(error):
    logging.error(f"An error occurred: {str(error)}")
    return jsonify({"message": "An internal error occurred"}), 500

def main():
    init_db()
    app.run(debug=True)

if __name__ == '__main__':
    main()