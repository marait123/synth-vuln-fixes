import logging
import traceback
from django.contrib.auth.models import User
from django.conf import settings
from django.core.mail import send_mail
from django.shortcuts import render
from smtplib import SMTPException
import re
from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.exceptions import ValidationError

logger = logging.getLogger(__name__)

class EmailValidationError(Exception):
    pass

def log_email_attempt(subject, recipients):
    logger.info(f"Attempting to send email: '{subject}' to {len(recipients)} recipients")

def create_email_body(template, **kwargs):
    return template.format(**kwargs)

def validate_email(email):
    pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    return re.match(pattern, email) is not None

def get_challenge_details():
    # Mock function to get challenge details from a database
    return {
        "name": "Sample Challenge",
        "start_date": "2023-06-01",
        "end_date": "2023-06-30",
        "description": "This is a sample challenge for testing purposes."
    }

def format_challenge_details(challenge):
    return f"Challenge: {challenge['name']}\nStart: {challenge['start_date']}\nEnd: {challenge['end_date']}\nDescription: {challenge['description']}"

@csrf_exempt
def notify_users_about_challenge(request):
    if not (request.user.is_authenticated and request.user.is_superuser):
        logger.warning(f"Unauthorized access attempt by user: {request.user}")
        return render(request, "error404.html")

    if request.method == "GET":
        template_name = "notification_email_data.html"
        return render(request, template_name)
    elif request.method == "POST":
        try:
            users = User.objects.exclude(email__exact="").values_list("email", flat=True)
            subject = request.POST.get("subject")
            body_template = request.POST.get("body_template")
            body_html_template = request.POST.get("body_html_template")

            if not subject or not body_template or not body_html_template:
                raise ValidationError("Missing required fields")

            challenge = get_challenge_details()
            body = create_email_body(body_template, challenge_name=challenge['name'])
            body_html = create_email_body(body_html_template, challenge_name=challenge['name'])

            sender = settings.EMAIL_SENDER
            valid_users = [user for user in users if validate_email(user)]

            if not valid_users:
                raise EmailValidationError("No valid email addresses found")

            log_email_attempt(subject, valid_users)

            send_mail(
                subject,
                body,
                sender,
                [settings.EMAIL],
                bcc=valid_users,
                html_message=body_html
            )
            logger.info("Email sent successfully")
            return HttpResponse("Email sent successfully")
        except ValidationError as ve:
            logger.error(f"Validation error: {str(ve)}")
            return render(request, "error_email.html", {"error": str(ve)})
        except EmailValidationError as eve:
            logger.error(f"Email validation error: {str(eve)}")
            return render(request, "error_email.html", {"error": str(eve)})
        except SMTPException as e:
            logger.error(f"Failed to send email: {str(e)}")
            return render(request, "error_email.html", {"error": str(e)})
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}")
            logger.error(traceback.format_exc())
            return render(request, "error500.html")
    else:
        logger.warning(f"Invalid request method: {request.method}")
        return render(request, "error404.html")

def list_challenges(request):
    if not request.user.is_authenticated:
        return render(request, "error404.html")

    challenges = [get_challenge_details()]  # In a real app, this would fetch from a database
    return render(request, "challenge_list.html", {"challenges": challenges})

def view_challenge(request, challenge_id):
    if not request.user.is_authenticated:
        return render(request, "error404.html")

    challenge = get_challenge_details()  # In a real app, this would fetch a specific challenge
    return render(request, "challenge_detail.html", {"challenge": challenge})

def create_challenge(request):
    if not (request.user.is_authenticated and request.user.is_superuser):
        return render(request, "error404.html")

    if request.method == "POST":
        # Process the form data and create a new challenge
        # This is a simplified version and doesn't actually create anything
        return HttpResponse("Challenge created successfully")
    else:
        return render(request, "create_challenge.html")

def update_challenge(request, challenge_id):
    if not (request.user.is_authenticated and request.user.is_superuser):
        return render(request, "error404.html")

    challenge = get_challenge_details()  # In a real app, this would fetch a specific challenge

    if request.method == "POST":
        # Process the form data and update the challenge
        # This is a simplified version and doesn't actually update anything
        return HttpResponse("Challenge updated successfully")
    else:
        return render(request, "update_challenge.html", {"challenge": challenge})

def delete_challenge(request, challenge_id):
    if not (request.user.is_authenticated and request.user.is_superuser):
        return render(request, "error404.html")

    if request.method == "POST":
        # Delete the challenge
        # This is a simplified version and doesn't actually delete anything
        return HttpResponse("Challenge deleted successfully")
    else:
        return render(request, "confirm_delete_challenge.html", {"challenge_id": challenge_id})

if __name__ == "__main__":
    # Simple test harness
    class MockRequest:
        def __init__(self, method, user, post_data=None):
            self.method = method
            self.user = user
            self.POST = post_data or {}

    class MockUser:
        def __init__(self, is_authenticated, is_superuser):
            self.is_authenticated = is_authenticated
            self.is_superuser = is_superuser

    mock_user = MockUser(True, True)
    mock_request = MockRequest("POST", mock_user, {
        "subject": "Test Subject",
        "body_template": "Hello {challenge_name}",
        "body_html_template": "<h1>Hello {challenge_name}</h1>"
    })

    result = notify_users_about_challenge(mock_request)
    print(result)