import sqlite3
import logging
from flask import Flask, request, jsonify, session
from werkzeug.security import generate_password_hash, check_password_hash
from functools import wraps
import os

app = Flask(__name__)
app.secret_key = os.urandom(24)  # Generate a random secret key

# Configure logging
logging.basicConfig(filename='app.log', level=logging.INFO,
                    format='%(asctime)s:%(levelname)s:%(message)s')

def get_db_connection():
    conn = sqlite3.connect('database.db')
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    conn = get_db_connection()
    conn.execute('CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, password TEXT NOT NULL)')
    conn.execute('CREATE TABLE IF NOT EXISTS notes (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, content TEXT NOT NULL, FOREIGN KEY (user_id) REFERENCES users (id))')
    conn.commit()
    conn.close()

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({'error': 'Unauthorized'}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/register', methods=['POST'])
def register():
    username = request.json.get('username')
    password = request.json.get('password')
    if not username or not password:
        return jsonify({'error': 'Username and password are required'}), 400
    
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        hashed_password = generate_password_hash(password)
        cursor.execute('INSERT INTO users (username, password) VALUES (?, ?)', (username, hashed_password))
        conn.commit()
        logging.info(f"User registered: {username}")
        return jsonify({'message': 'User registered successfully'}), 201
    except sqlite3.IntegrityError:
        return jsonify({'error': 'Username already exists'}), 409
    except Exception as e:
        logging.error(f"Error during registration: {str(e)}")
        return jsonify({'error': 'An error occurred during registration'}), 500
    finally:
        conn.close()

@app.route('/login', methods=['POST'])
def login():
    username = request.json.get('username')
    password = request.json.get('password')
    try:
        conn = get_db_connection()
        user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()
        if user and check_password_hash(user['password'], password):
            session['user_id'] = user['id']
            logging.info(f"User logged in: {username}")
            return jsonify({'message': 'Logged in successfully'}), 200
        return jsonify({'error': 'Invalid credentials'}), 401
    except Exception as e:
        logging.error(f"Error during login: {str(e)}")
        return jsonify({'error': 'An error occurred during login'}), 500
    finally:
        conn.close()

@app.route('/logout', methods=['POST'])
@login_required
def logout():
    session.pop('user_id', None)
    return jsonify({'message': 'Logged out successfully'}), 200

@app.route('/notes', methods=['GET', 'POST'])
@login_required
def notes():
    if request.method == 'POST':
        content = request.json.get('content')
        if not content:
            return jsonify({'error': 'Content is required'}), 400
        try:
            conn = get_db_connection()
            cursor = conn.cursor()
            cursor.execute('INSERT INTO notes (user_id, content) VALUES (?, ?)', (session['user_id'], content))
            conn.commit()
            logging.info(f"Note created for user_id: {session['user_id']}")
            return jsonify({'message': 'Note created successfully'}), 201
        except Exception as e:
            logging.error(f"Error creating note: {str(e)}")
            return jsonify({'error': 'An error occurred while creating the note'}), 500
        finally:
            conn.close()
    
    try:
        conn = get_db_connection()
        notes = conn.execute('SELECT * FROM notes WHERE user_id = ?', (session['user_id'],)).fetchall()
        return jsonify([dict(note) for note in notes]), 200
    except Exception as e:
        logging.error(f"Error fetching notes: {str(e)}")
        return jsonify({'error': 'An error occurred while fetching notes'}), 500
    finally:
        conn.close()

@app.route('/notes/<int:note_id>', methods=['GET', 'PUT', 'DELETE'])
@login_required
def note(note_id):
    try:
        conn = get_db_connection()
        note = conn.execute('SELECT * FROM notes WHERE id = ? AND user_id = ?', (note_id, session['user_id'])).fetchone()
        
        if not note:
            return jsonify({'error': 'Note not found'}), 404
        
        if request.method == 'GET':
            return jsonify(dict(note)), 200
        
        elif request.method == 'PUT':
            content = request.json.get('content')
            if not content:
                return jsonify({'error': 'Content is required'}), 400
            cursor = conn.cursor()
            cursor.execute('UPDATE notes SET content = ? WHERE id = ?', (content, note_id))
            conn.commit()
            logging.info(f"Note updated: {note_id}")
            return jsonify({'message': 'Note updated successfully'}), 200
        
        elif request.method == 'DELETE':
            cursor = conn.cursor()
            cursor.execute('DELETE FROM notes WHERE id = ?', (note_id,))
            conn.commit()
            logging.info(f"Note deleted: {note_id}")
            return jsonify({'message': 'Note deleted successfully'}), 200
    except Exception as e:
        logging.error(f"Error handling note {note_id}: {str(e)}")
        return jsonify({'error': 'An error occurred while processing the note'}), 500
    finally:
        conn.close()

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({'status': 'healthy'}), 200

if __name__ == '__main__':
    init_db()
    app.run(debug=True)