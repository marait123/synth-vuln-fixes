import aioredis
import sqlite3
import logging
import json
import asyncio
from sanic import Sanic, response
from sanic.log import logger
from sanic_jwt import Initialize, protected
from datetime import datetime

class CustomException(Exception):
    pass

class AnalyticsApp:
    def __init__(self):
        self.redis = None
        self.db = None
        self.app = Sanic("AnalyticsApp")
        Initialize(self.app, authenticate=self.authenticate)
        self.setup_routes()
        self.setup_logging()

    async def setup_redis(self):
        try:
            self.redis = await aioredis.create_redis_pool('redis://localhost')
            logger.info("Redis connection established")
        except Exception as e:
            logger.error(f"Redis connection failed: {str(e)}")
            raise CustomException("Redis connection failed")

    def setup_database(self):
        try:
            self.db = sqlite3.connect('users.db')
            cursor = self.db.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users
                (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT, created_at TIMESTAMP)
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS events
                (id INTEGER PRIMARY KEY, user_id INTEGER, event_type TEXT, event_data TEXT, timestamp TIMESTAMP)
            ''')
            self.db.commit()
            logger.info("Database setup completed")
        except sqlite3.Error as e:
            logger.error(f"Database setup failed: {str(e)}")
            raise CustomException("Database setup failed")

    def setup_routes(self):
        self.app.add_route(self.track_event, '/track', methods=['POST'])
        self.app.add_route(self.register_user, '/register', methods=['POST'])
        self.app.add_route(self.get_user_data, '/user_data', methods=['GET'])
        self.app.add_route(self.update_user, '/update_user', methods=['PUT'])
        self.app.add_route(self.delete_user, '/delete_user', methods=['DELETE'])
        self.app.add_route(self.get_events, '/events', methods=['GET'])

    def setup_logging(self):
        logging.basicConfig(filename='app.log', level=logging.INFO,
                            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    def start_server(self):
        self.app.run(host='0.0.0.0', port=8000)

    @protected()
    async def track_event(self, request):
        try:
            event_data = request.json
            if not event_data or 'event_type' not in event_data:
                raise ValueError("Invalid event data")
            
            user_id = request.app.auth.extract_user_id(request)
            event = {
                'user_id': user_id,
                'event_type': event_data['event_type'],
                'event_data': json.dumps(event_data.get('data', {})),
                'timestamp': datetime.now().isoformat()
            }
            await self.redis.lpush('events', json.dumps(event))
            
            cursor = self.db.cursor()
            cursor.execute('''
                INSERT INTO events (user_id, event_type, event_data, timestamp)
                VALUES (?, ?, ?, ?)
            ''', (user_id, event['event_type'], event['event_data'], event['timestamp']))
            self.db.commit()
            
            logger.info(f"Event tracked: {event}")
            return response.json({'status': 'success'})
        except Exception as e:
            logger.error(f"Error tracking event: {str(e)}")
            return response.json({'status': 'error', 'message': str(e)}, status=400)

    async def register_user(self, request):
        try:
            username = request.json.get('username')
            password = request.json.get('password')
            if not username or not password:
                raise ValueError("Username and password are required")
            
            cursor = self.db.cursor()
            cursor.execute("INSERT INTO users (username, password, created_at) VALUES (?, ?, ?)",
                           (username, password, datetime.now().isoformat()))
            self.db.commit()
            logger.info(f"User registered: {username}")
            return response.json({'status': 'success'})
        except sqlite3.IntegrityError:
            return response.json({'status': 'error', 'message': 'Username already exists'}, status=400)
        except Exception as e:
            logger.error(f"Error registering user: {str(e)}")
            return response.json({'status': 'error', 'message': str(e)}, status=400)

    @protected()
    async def get_user_data(self, request):
        try:
            user_id = request.app.auth.extract_user_id(request)
            cursor = self.db.cursor()
            cursor.execute("SELECT id, username, created_at FROM users WHERE id = ?", (user_id,))
            user_data = cursor.fetchone()
            if user_data:
                return response.json({'status': 'success', 'data': {
                    'id': user_data[0],
                    'username': user_data[1],
                    'created_at': user_data[2]
                }})
            return response.json({'status': 'error', 'message': 'User not found'}, status=404)
        except Exception as e:
            logger.error(f"Error getting user data: {str(e)}")
            return response.json({'status': 'error', 'message': str(e)}, status=400)

    @protected()
    async def update_user(self, request):
        try:
            user_id = request.app.auth.extract_user_id(request)
            new_password = request.json.get('new_password')
            if not new_password:
                raise ValueError("New password is required")
            
            cursor = self.db.cursor()
            cursor.execute("UPDATE users SET password = ? WHERE id = ?", (new_password, user_id))
            self.db.commit()
            logger.info(f"User updated: {user_id}")
            return response.json({'status': 'success'})
        except Exception as e:
            logger.error(f"Error updating user: {str(e)}")
            return response.json({'status': 'error', 'message': str(e)}, status=400)

    @protected()
    async def delete_user(self, request):
        try:
            user_id = request.app.auth.extract_user_id(request)
            cursor = self.db.cursor()
            cursor.execute("DELETE FROM users WHERE id = ?", (user_id,))
            self.db.commit()
            logger.info(f"User deleted: {user_id}")
            return response.json({'status': 'success'})
        except Exception as e:
            logger.error(f"Error deleting user: {str(e)}")
            return response.json({'status': 'error', 'message': str(e)}, status=400)

    @protected()
    async def get_events(self, request):
        try:
            user_id = request.app.auth.extract_user_id(request)
            cursor = self.db.cursor()
            cursor.execute("SELECT * FROM events WHERE user_id = ?", (user_id,))
            events = cursor.fetchall()
            return response.json({'status': 'success', 'events': [
                {'id': e[0], 'event_type': e[2], 'event_data': json.loads(e[3]), 'timestamp': e[4]}
                for e in events
            ]})
        except Exception as e:
            logger.error(f"Error getting events: {str(e)}")
            return response.json({'status': 'error', 'message': str(e)}, status=400)

    async def authenticate(self, request):
        try:
            username = request.json.get('username')
            password = request.json.get('password')
            cursor = self.db.cursor()
            cursor.execute("SELECT * FROM users WHERE username = ? AND password = ?", (username, password))
            user = cursor.fetchone()
            if user:
                return {'user_id': user[0]}
            return None
        except Exception as e:
            logger.error(f"Authentication error: {str(e)}")
            return None

async def main():
    app = AnalyticsApp()
    await app.setup_redis()
    app.setup_database()
    app.start_server()

if __name__ == "__main__":
    asyncio.run(main())