from flask import Flask, request, jsonify
import requests
import sqlite3
from functools import wraps
import logging
import jwt
import datetime
import os

app = Flask(__name__)
app.config['SECRET_KEY'] = 'supersecretkey'  # Vulnerable: Hardcoded secret key

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def init_db():
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS users
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  username TEXT UNIQUE NOT NULL,
                  email TEXT UNIQUE NOT NULL,
                  password TEXT NOT NULL)''')
    conn.commit()
    conn.close()

init_db()

profile_cache = {}

def verify_user():
    token = request.headers.get('Authorization')
    if not token:
        return None
    try:
        data = jwt.decode(token.split()[1], app.config['SECRET_KEY'], algorithms=['HS256'])
        return data
    except:
        return None

def auth_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        user = verify_user()
        if not user:
            return jsonify({"error": "Authentication failed"}), 401
        return f(user, *args, **kwargs)
    return decorated

@app.route('/user/profile', methods=['GET'])
@auth_required
def get_user_profile(user):
    if user['id'] in profile_cache:
        logger.info(f"Returning cached profile for user {user['id']}")
        return jsonify(profile_cache[user['id']])
    
    logger.info(f"Fetching profile for user {user['id']}")
    profile_cache[user['id']] = user
    return jsonify(user)

@app.route('/user/create', methods=['POST'])
def create_user():
    data = request.json
    if not data or 'username' not in data or 'email' not in data or 'password' not in data:
        return jsonify({"error": "Missing required fields"}), 400

    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    try:
        c.execute("INSERT INTO users (username, email, password) VALUES (?, ?, ?)",
                  (data['username'], data['email'], data['password']))  # Vulnerable: Storing plain text password
        conn.commit()
        logger.info(f"User {data['username']} created successfully")
        return jsonify({"message": "User created successfully"}), 201
    except sqlite3.IntegrityError:
        logger.warning(f"Failed to create user {data['username']}: Username or email already exists")
        return jsonify({"error": "Username or email already exists"}), 400
    finally:
        conn.close()

@app.route('/user/update', methods=['PUT'])
@auth_required
def update_user(current_user):
    data = request.json
    if not data or 'email' not in data:
        return jsonify({"error": "Missing email field"}), 400

    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    try:
        c.execute("UPDATE users SET email = ? WHERE username = ?",
                  (data['email'], current_user['username']))
        conn.commit()
        logger.info(f"User {current_user['username']} updated successfully")
        return jsonify({"message": "User updated successfully"})
    except sqlite3.Error as e:
        logger.error(f"Error updating user {current_user['username']}: {str(e)}")
        return jsonify({"error": "Failed to update user"}), 500
    finally:
        conn.close()

@app.route('/user/delete', methods=['DELETE'])
@auth_required
def delete_user(current_user):
    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    try:
        c.execute("DELETE FROM users WHERE username = ?", (current_user['username'],))
        conn.commit()
        logger.info(f"User {current_user['username']} deleted successfully")
        return jsonify({"message": "User deleted successfully"})
    except sqlite3.Error as e:
        logger.error(f"Error deleting user {current_user['username']}: {str(e)}")
        return jsonify({"error": "Failed to delete user"}), 500
    finally:
        conn.close()

@app.route('/login', methods=['POST'])
def login():
    data = request.json
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({"error": "Missing username or password"}), 400

    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute("SELECT * FROM users WHERE username = ? AND password = ?", (data['username'], data['password']))
    user = c.fetchone()
    conn.close()

    if user:
        token = jwt.encode({
            'id': user[0],
            'username': user[1],
            'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=1)
        }, app.config['SECRET_KEY'])
        logger.info(f"User {data['username']} logged in successfully")
        return jsonify({"token": token})
    else:
        logger.warning(f"Failed login attempt for user {data['username']}")
        return jsonify({"error": "Invalid credentials"}), 401

@app.route('/user/search', methods=['GET'])
@auth_required
def search_users(current_user):
    query = request.args.get('q')
    if not query:
        return jsonify({"error": "Missing search query"}), 400

    conn = sqlite3.connect('users.db')
    c = conn.cursor()
    c.execute("SELECT username, email FROM users WHERE username LIKE ? OR email LIKE ?",
              (f"%{query}%", f"%{query}%"))  # Vulnerable: SQL Injection
    results = c.fetchall()
    conn.close()

    return jsonify([{"username": r[0], "email": r[1]} for r in results])

if __name__ == '__main__':
    app.run(debug=True)