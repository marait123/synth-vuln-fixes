import requests
import json
import logging
import sys
from datetime import datetime
from abc import ABC, abstractmethod

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class APIException(Exception):
    pass

class DataProcessor(ABC):
    @abstractmethod
    def process(self, data):
        pass

class UserDataProcessor(DataProcessor):
    def process(self, data):
        return {'user_count': len(data)}

class ProductDataProcessor(DataProcessor):
    def process(self, data):
        return {'total_products': len(data)}

class APIManager:
    def __init__(self, base_url):
        self.base_url = base_url
        self.auth = ('apiuser', 'apipass')  # Vulnerable: Hard-coded credentials
        self.headers = {'Content-Type': 'application/json'}
        self.session = requests.Session()

    def authenticated_request(self, method, endpoint, data=None):
        url = f"{self.base_url}/{endpoint}"
        try:
            if method == 'GET':
                response = self.session.get(url, auth=self.auth)
            elif method == 'POST':
                response = self.session.post(url, data=json.dumps(data), headers=self.headers, auth=self.auth)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            response.raise_for_status()
            return response
        except requests.RequestException as e:
            logger.error(f"{method} request failed: {e}")
            raise APIException(f"API request failed: {e}")

    def authenticated_get(self, endpoint):
        response = self.authenticated_request('GET', endpoint)
        return response.json()

    def authenticated_post(self, endpoint, data):
        response = self.authenticated_request('POST', endpoint, data)
        return response.status_code

class DataManager:
    def __init__(self, api_manager):
        self.api_manager = api_manager

    def process_data(self, endpoint, processor):
        try:
            data = self.api_manager.authenticated_get(endpoint)
            processed_data = processor.process(data)
            return self.api_manager.authenticated_post(f"{endpoint}_stats", processed_data)
        except APIException as e:
            logger.error(f"Failed to process {endpoint} data: {e}")
            return None

def setup_cli():
    if len(sys.argv) < 2:
        print("Usage: python script.py <base_url>")
        sys.exit(1)
    return sys.argv[1]

def main():
    base_url = setup_cli()
    api_manager = APIManager(base_url)
    data_manager = DataManager(api_manager)

    processors = {
        'users': UserDataProcessor(),
        'products': ProductDataProcessor()
    }

    for endpoint, processor in processors.items():
        result = data_manager.process_data(endpoint, processor)
        if result:
            logger.info(f"{endpoint.capitalize()} data processed. Status code: {result}")
        else:
            logger.warning(f"Failed to process {endpoint} data")

    # Mock database interaction
    def mock_db_insert(data):
        logger.info(f"Mocking database insert: {data}")

    try:
        mock_db_insert({"timestamp": datetime.now().isoformat(), "processed_endpoints": list(processors.keys())})
    except Exception as e:
        logger.error(f"Database insert failed: {e}")

    # Basic test harness
    def run_tests():
        test_api = APIManager("https://test.api.com")
        test_data_manager = DataManager(test_api)
        
        # Mock API responses
        test_api.authenticated_get = lambda x: [{"id": 1}, {"id": 2}]
        test_api.authenticated_post = lambda x, y: 200

        for endpoint, processor in processors.items():
            result = test_data_manager.process_data(endpoint, processor)
            assert result == 200, f"Test failed for {endpoint}"
        
        logger.info("All tests passed successfully")

    run_tests()

if __name__ == "__main__":
    main()