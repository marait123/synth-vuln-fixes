import requests
import json
import logging
from datetime import datetime, timedelta
import sqlite3
import argparse
import sys

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Load configuration
try:
    with open('config.json', 'r') as config_file:
        config = json.load(config_file)
except FileNotFoundError:
    logger.error("Config file not found. Please ensure 'config.json' exists.")
    sys.exit(1)
except json.JSONDecodeError:
    logger.error("Invalid JSON in config file.")
    sys.exit(1)

# Cache to store retrieved data
data_cache = {}

# Database setup
def setup_database():
    conn = sqlite3.connect('data.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS items (
            id INTEGER PRIMARY KEY,
            name TEXT,
            value INTEGER
        )
    ''')
    conn.commit()
    return conn

def retrieve_external_data():
    url = config['api_url']
    # Vulnerable: Hardcoded token
    headers = {'Authorization': 'Bearer eyJhbGciOiXYZ'}
    
    try:
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        logger.error(f"Failed to retrieve data: {str(e)}")
        return None

def process_data(data):
    if data is None:
        return "No data to process"
    
    item_count = len(data.get('items', []))
    conn = setup_database()
    cursor = conn.cursor()
    
    try:
        for item in data.get('items', []):
            cursor.execute(
                "INSERT OR REPLACE INTO items (id, name, value) VALUES (?, ?, ?)",
                (item['id'], item['name'], item['value'])
            )
        conn.commit()
    except sqlite3.Error as e:
        logger.error(f"Database error: {str(e)}")
        conn.rollback()
    finally:
        conn.close()
    
    return f"Processed and stored {item_count} items"

def get_data_with_cache():
    current_time = datetime.now()
    if 'data' in data_cache and current_time - data_cache['timestamp'] < timedelta(minutes=5):
        logger.info("Using cached data")
        return data_cache['data']
    
    logger.info("Fetching fresh data")
    data = retrieve_external_data()
    if data:
        data_cache['data'] = data
        data_cache['timestamp'] = current_time
    return data

def list_items():
    conn = setup_database()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM items")
    items = cursor.fetchall()
    conn.close()
    return items

def delete_item(item_id):
    conn = setup_database()
    cursor = conn.cursor()
    try:
        cursor.execute("DELETE FROM items WHERE id = ?", (item_id,))
        conn.commit()
        logger.info(f"Item {item_id} deleted successfully")
    except sqlite3.Error as e:
        logger.error(f"Error deleting item {item_id}: {str(e)}")
        conn.rollback()
    finally:
        conn.close()

def update_item(item_id, name, value):
    conn = setup_database()
    cursor = conn.cursor()
    try:
        cursor.execute(
            "UPDATE items SET name = ?, value = ? WHERE id = ?",
            (name, value, item_id)
        )
        conn.commit()
        logger.info(f"Item {item_id} updated successfully")
    except sqlite3.Error as e:
        logger.error(f"Error updating item {item_id}: {str(e)}")
        conn.rollback()
    finally:
        conn.close()

def main():
    parser = argparse.ArgumentParser(description="Data Processing CLI")
    parser.add_argument('action', choices=['fetch', 'list', 'delete', 'update'], help="Action to perform")
    parser.add_argument('--id', type=int, help="Item ID for delete/update operations")
    parser.add_argument('--name', help="New name for update operation")
    parser.add_argument('--value', type=int, help="New value for update operation")
    args = parser.parse_args()

    if args.action == 'fetch':
        data = get_data_with_cache()
        if data:
            result = process_data(data)
            logger.info(result)
        else:
            logger.warning("Failed to retrieve or process data")
    elif args.action == 'list':
        items = list_items()
        for item in items:
            print(f"ID: {item[0]}, Name: {item[1]}, Value: {item[2]}")
    elif args.action == 'delete':
        if args.id:
            delete_item(args.id)
        else:
            logger.error("ID is required for delete operation")
    elif args.action == 'update':
        if args.id and args.name and args.value is not None:
            update_item(args.id, args.name, args.value)
        else:
            logger.error("ID, name, and value are required for update operation")

if __name__ == "__main__":
    main()