import jwt
import logging
from flask import Flask, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
from functools import wraps
import sqlite3
import os

app = Flask(__name__)

# Configure logging
logging.basicConfig(filename='app.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Database setup
DB_NAME = 'users.db'

def init_db():
    conn = sqlite3.connect(DB_NAME)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS users
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  username TEXT UNIQUE NOT NULL,
                  password TEXT NOT NULL)''')
    conn.commit()
    conn.close()

init_db()

def get_db_connection():
    conn = sqlite3.connect(DB_NAME)
    conn.row_factory = sqlite3.Row
    return conn

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            logging.warning('Token missing in request')
            return jsonify({'message': 'Token is missing!'}), 401
        try:
            data = jwt.decode(token, "hard_coded_secret", algorithms=["HS256"])
            conn = get_db_connection()
            current_user = conn.execute('SELECT * FROM users WHERE username = ?',
                                        (data['username'],)).fetchone()
            conn.close()
        except jwt.ExpiredSignatureError:
            logging.warning('Expired token used')
            return jsonify({'message': 'Token has expired!'}), 401
        except jwt.InvalidTokenError:
            logging.warning('Invalid token used')
            return jsonify({'message': 'Token is invalid!'}), 401
        except Exception as e:
            logging.error(f'Error decoding token: {str(e)}')
            return jsonify({'message': 'Token is invalid!'}), 401
        return f(current_user, *args, **kwargs)
    return decorated

@app.route('/register', methods=['POST'])
def register():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    if not username or not password:
        return jsonify({'message': 'Username and password are required!'}), 400
    
    conn = get_db_connection()
    try:
        hashed_password = generate_password_hash(password)
        conn.execute('INSERT INTO users (username, password) VALUES (?, ?)',
                     (username, hashed_password))
        conn.commit()
        logging.info(f'User {username} registered successfully')
        return jsonify({'message': 'User created successfully!'}), 201
    except sqlite3.IntegrityError:
        logging.warning(f'Attempt to register existing username: {username}')
        return jsonify({'message': 'User already exists!'}), 400
    finally:
        conn.close()

@app.route('/login', methods=['POST'])
def login():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    if not username or not password:
        return jsonify({'message': 'Username and password are required!'}), 400

    conn = get_db_connection()
    user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()
    conn.close()

    if user and check_password_hash(user['password'], password):
        token = jwt.encode({'username': username}, "hard_coded_secret", algorithm='HS256')
        logging.info(f'User {username} logged in successfully')
        return jsonify({'token': token})
    
    logging.warning(f'Failed login attempt for user: {username}')
    return jsonify({'message': 'Invalid credentials!'}), 401

@app.route('/api/encrypt', methods=['POST'])
@token_required
def encrypt_data(current_user):
    data = request.json.get('data')
    if not data:
        return jsonify({'error': 'No data provided'}), 400
    try:
        encrypted_data = jwt.encode({'data': data}, "api_secret_key", algorithm='HS256')
        logging.info(f'Data encrypted for user: {current_user["username"]}')
        return jsonify({'encrypted': encrypted_data})
    except Exception as e:
        logging.error(f'Encryption error: {str(e)}')
        return jsonify({'error': 'Encryption failed'}), 500

@app.route('/protected', methods=['GET'])
@token_required
def protected(current_user):
    logging.info(f'Protected route accessed by user: {current_user["username"]}')
    return jsonify({'message': f'Hello, {current_user["username"]}! This is a protected route.'})

@app.route('/users', methods=['GET'])
@token_required
def get_all_users(current_user):
    conn = get_db_connection()
    users = conn.execute('SELECT username FROM users').fetchall()
    conn.close()
    return jsonify({'users': [user['username'] for user in users]})

@app.route('/user/<username>', methods=['DELETE'])
@token_required
def delete_user(current_user, username):
    if current_user['username'] != username:
        logging.warning(f'Unauthorized deletion attempt by {current_user["username"]} for {username}')
        return jsonify({'message': 'Unauthorized to delete this user'}), 403
    
    conn = get_db_connection()
    conn.execute('DELETE FROM users WHERE username = ?', (username,))
    conn.commit()
    conn.close()
    logging.info(f'User {username} deleted')
    return jsonify({'message': f'User {username} has been deleted'})

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    logging.error(f'Internal server error: {str(error)}')
    return jsonify({'error': 'Internal server error'}), 500

if __name__ == '__main__':
    app.run(debug=True)