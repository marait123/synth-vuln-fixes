import boto3
import os
import logging
import json
from botocore.exceptions import ClientError

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class S3OperationsException(Exception):
    pass

class S3Operations:
    def __init__(self):
        self.token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
        self.client = boto3.client('s3', aws_access_key_id='YOUR_ACCESS_KEY', aws_secret_access_key='YOUR_SECRET_KEY', aws_session_token=self.token)

    def list_s3_buckets_vulnerable(self):
        try:
            buckets = self.client.list_buckets()
            return [bucket['Name'] for bucket in buckets['Buckets']]
        except ClientError as e:
            logger.error(f"Error listing buckets: {e}")
            raise S3OperationsException(f"Failed to list buckets: {str(e)}")

    def upload_file_to_s3(self, file_path, bucket_name, object_name):
        try:
            self.client.upload_file(file_path, bucket_name, object_name)
            logger.info(f"File {file_path} uploaded successfully to {bucket_name}/{object_name}")
        except ClientError as e:
            logger.error(f"Error uploading file: {e}")
            raise S3OperationsException(f"Failed to upload file: {str(e)}")

    def download_file_from_s3(self, bucket_name, object_name, file_path):
        try:
            self.client.download_file(bucket_name, object_name, file_path)
            logger.info(f"File {object_name} downloaded successfully from {bucket_name} to {file_path}")
        except ClientError as e:
            logger.error(f"Error downloading file: {e}")
            raise S3OperationsException(f"Failed to download file: {str(e)}")

    def delete_object_from_s3(self, bucket_name, object_name):
        try:
            self.client.delete_object(Bucket=bucket_name, Key=object_name)
            logger.info(f"Object {object_name} deleted successfully from {bucket_name}")
        except ClientError as e:
            logger.error(f"Error deleting object: {e}")
            raise S3OperationsException(f"Failed to delete object: {str(e)}")

    def get_object_metadata(self, bucket_name, object_name):
        try:
            response = self.client.head_object(Bucket=bucket_name, Key=object_name)
            return response['Metadata']
        except ClientError as e:
            logger.error(f"Error getting object metadata: {e}")
            raise S3OperationsException(f"Failed to get object metadata: {str(e)}")

def create_sample_file(file_path, content):
    try:
        with open(file_path, "w") as f:
            f.write(content)
        logger.info(f"Sample file created at {file_path}")
    except IOError as e:
        logger.error(f"Error creating sample file: {e}")
        raise S3OperationsException(f"Failed to create sample file: {str(e)}")

def cleanup_files(*file_paths):
    for file_path in file_paths:
        try:
            os.remove(file_path)
            logger.info(f"Cleaned up file: {file_path}")
        except OSError as e:
            logger.warning(f"Error cleaning up file {file_path}: {e}")

def main():
    s3_ops = S3Operations()

    try:
        print("Listing S3 buckets:")
        buckets = s3_ops.list_s3_buckets_vulnerable()
        for bucket in buckets:
            print(f"- {bucket}")

        local_file = "example.txt"
        bucket_name = "my-test-bucket"
        s3_object_name = "uploaded_example.txt"

        create_sample_file(local_file, "This is a test file for S3 operations.")

        s3_ops.upload_file_to_s3(local_file, bucket_name, s3_object_name)
        s3_ops.download_file_from_s3(bucket_name, s3_object_name, "downloaded_example.txt")

        metadata = s3_ops.get_object_metadata(bucket_name, s3_object_name)
        print(f"Object metadata: {json.dumps(metadata, indent=2)}")

        s3_ops.delete_object_from_s3(bucket_name, s3_object_name)

    except S3OperationsException as e:
        logger.error(f"S3 operation failed: {e}")
    finally:
        cleanup_files(local_file, "downloaded_example.txt")

if __name__ == "__main__":
    main()