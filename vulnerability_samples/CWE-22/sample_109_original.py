import os
import time
import logging
import shutil
from django.http import HttpResponse, StreamingHttpResponse, JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.exceptions import ValidationError
from django.utils.text import slugify
from django.conf import settings
import magic
import requests

logging.basicConfig(filename='file_operations.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

UPLOAD_DIR = 'uploads'
ALLOWED_EXTENSIONS = ['.docx', '.xlsx']
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB

class FileOperationException(Exception):
    pass

def sanitize_filename(filename):
    return slugify(filename)

def validate_file_type(file):
    mime = magic.Magic(mime=True)
    file_type = mime.from_buffer(file.read(1024))
    file.seek(0)
    if file_type not in ['application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                         'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet']:
        raise ValidationError("Invalid file type")

def download_doc(request):
    url = request.GET.get('url')
    if not url:
        return HttpResponse('No URL provided', status=400)

    file_extension = os.path.splitext(url)[1]
    if file_extension not in ALLOWED_EXTENSIONS:
        return HttpResponse('Invalid file format', status=400)

    file_name = f"{int(time.time())}{file_extension}"
    
    def file_iterator(_file, chunk_size=512):
        while True:
            c = _file.read(chunk_size)
            if c:
                yield c
            else:
                break
    
    try:
        response = requests.get(url, stream=True)
        response.raise_for_status()
        
        _file = response.raw
        streaming_response = StreamingHttpResponse(file_iterator(_file))
        streaming_response['Content-Type'] = 'application/octet-stream'
        streaming_response['Content-Disposition'] = f'attachment;filename="{file_name}"'
        logging.info(f"File downloaded: {url}")
        return streaming_response
    except requests.RequestException as e:
        logging.error(f"Error downloading file: {url}. Error: {str(e)}")
        return HttpResponse('Error downloading file', status=500)

@csrf_exempt
def upload_file(request):
    if request.method != 'POST':
        return HttpResponse('Method not allowed', status=405)

    file = request.FILES.get('file')
    if not file:
        return HttpResponse('No file provided', status=400)

    try:
        validate_file_type(file)
        if file.size > MAX_FILE_SIZE:
            raise ValidationError("File size exceeds maximum limit")

        safe_filename = sanitize_filename(file.name)
        file_extension = os.path.splitext(safe_filename)[1]
        if file_extension not in ALLOWED_EXTENSIONS:
            raise ValidationError("Invalid file type")

        file_path = os.path.join(UPLOAD_DIR, safe_filename)
        with open(file_path, 'wb+') as destination:
            for chunk in file.chunks():
                destination.write(chunk)
        logging.info(f"File uploaded: {safe_filename}")
        return HttpResponse('File uploaded successfully', status=200)
    except ValidationError as e:
        logging.warning(f"Validation error: {str(e)}")
        return HttpResponse(str(e), status=400)
    except Exception as e:
        logging.error(f"Error uploading file: {str(e)}")
        return HttpResponse('Internal server error', status=500)

def list_files(request):
    try:
        files = os.listdir(UPLOAD_DIR)
        file_list = [{"name": f, "size": os.path.getsize(os.path.join(UPLOAD_DIR, f))} for f in files]
        return JsonResponse({"files": file_list})
    except Exception as e:
        logging.error(f"Error listing files: {str(e)}")
        return HttpResponse('Error listing files', status=500)

def delete_file(request):
    filename = request.GET.get('filename')
    if not filename:
        return HttpResponse('No filename provided', status=400)

    try:
        safe_filename = sanitize_filename(filename)
        file_path = os.path.join(UPLOAD_DIR, safe_filename)
        if os.path.exists(file_path):
            os.remove(file_path)
            logging.info(f"File deleted: {safe_filename}")
            return HttpResponse('File deleted successfully', status=200)
        else:
            logging.warning(f"File not found for deletion: {safe_filename}")
            return HttpResponse('File not found', status=404)
    except Exception as e:
        logging.error(f"Error deleting file: {str(e)}")
        return HttpResponse('Error deleting file', status=500)

def move_file(request):
    source = request.GET.get('source')
    destination = request.GET.get('destination')
    if not source or not destination:
        return HttpResponse('Source and destination required', status=400)

    try:
        safe_source = sanitize_filename(source)
        safe_destination = sanitize_filename(destination)
        source_path = os.path.join(UPLOAD_DIR, safe_source)
        destination_path = os.path.join(UPLOAD_DIR, safe_destination)
        
        shutil.move(source_path, destination_path)
        logging.info(f"File moved: {safe_source} to {safe_destination}")
        return HttpResponse('File moved successfully', status=200)
    except FileNotFoundError:
        logging.warning(f"File not found: {safe_source}")
        return HttpResponse('File not found', status=404)
    except Exception as e:
        logging.error(f"Error moving file: {str(e)}")
        return HttpResponse('Error moving file', status=500)

def file_details(request):
    filename = request.GET.get('filename')
    if not filename:
        return HttpResponse('No filename provided', status=400)

    try:
        safe_filename = sanitize_filename(filename)
        file_path = os.path.join(UPLOAD_DIR, safe_filename)
        if os.path.exists(file_path):
            stats = os.stat(file_path)
            details = {
                "name": safe_filename,
                "size": stats.st_size,
                "created": time.ctime(stats.st_ctime),
                "modified": time.ctime(stats.st_mtime),
                "type": magic.from_file(file_path, mime=True)
            }
            return JsonResponse(details)
        else:
            return HttpResponse('File not found', status=404)
    except Exception as e:
        logging.error(f"Error getting file details: {str(e)}")
        return HttpResponse('Error getting file details', status=500)

if __name__ == "__main__":
    if not os.path.exists(UPLOAD_DIR):
        os.makedirs(UPLOAD_DIR)
    logging.info("File operations module initialized")