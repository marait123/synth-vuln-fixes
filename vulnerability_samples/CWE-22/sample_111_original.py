import os
import logging
from django.http import FileResponse, HttpResponse, JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout
from django.db import models
from django.conf import settings
from django.core.exceptions import ValidationError
from django.utils.timezone import now
from django.core.paginator import Paginator
from django.views.decorators.http import require_http_methods

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class FileMetadata(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    filename = models.CharField(max_length=255)
    upload_date = models.DateTimeField(auto_now_add=True)
    file_size = models.IntegerField()
    file_type = models.CharField(max_length=10)

    def __str__(self):
        return f"{self.filename} - {self.user.username}"

    def clean(self):
        if self.file_type not in ['pdf', 'txt', 'doc']:
            raise ValidationError("Invalid file type")

class CustomFileNotFoundError(Exception):
    pass

def user_login(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)
        if user is not None:
            login(request, user)
            logger.info(f"User {username} logged in successfully")
            return redirect('file_list')
        else:
            logger.warning(f"Failed login attempt for user {username}")
    return render(request, 'login.html')

@login_required
def user_logout(request):
    username = request.user.username
    logout(request)
    logger.info(f"User {username} logged out")
    return redirect('login')

@login_required
@require_http_methods(["GET", "POST"])
def file_upload(request):
    if request.method == 'POST':
        file = request.FILES.get('file')
        if file:
            filename = file.name
            file_extension = filename.split('.')[-1].lower()
            if file_extension in ['pdf', 'txt', 'doc']:
                file_path = os.path.join(settings.MEDIA_ROOT, 'user_files', filename)
                try:
                    with open(file_path, 'wb+') as destination:
                        for chunk in file.chunks():
                            destination.write(chunk)
                    FileMetadata.objects.create(
                        user=request.user,
                        filename=filename,
                        file_size=file.size,
                        file_type=file_extension
                    )
                    logger.info(f"File {filename} uploaded by {request.user.username}")
                    return redirect('file_list')
                except IOError as e:
                    logger.error(f"Error writing file {filename}: {str(e)}")
                    return JsonResponse({'error': 'Error writing file'}, status=500)
            else:
                logger.warning(f"Invalid file type {file_extension} attempted by {request.user.username}")
                return JsonResponse({'error': 'Invalid file type'}, status=400)
    return render(request, 'upload.html')

@login_required
def file_list(request):
    files = FileMetadata.objects.filter(user=request.user).order_by('-upload_date')
    paginator = Paginator(files, 10)  # Show 10 files per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    return render(request, 'file_list.html', {'page_obj': page_obj})

@csrf_exempt
@login_required
def file_response(request):
    filename = request.POST.get('filename')
    if not filename:
        logger.warning(f"File download attempted without filename by {request.user.username}")
        return JsonResponse({'error': 'No filename provided'}, status=400)
    file_extension = filename.split('.')[-1].lower()
    if file_extension not in ['pdf', 'txt', 'doc']:
        logger.warning(f"Invalid file type {file_extension} download attempted by {request.user.username}")
        return JsonResponse({'error': 'Invalid file type'}, status=400)
    file_path = os.path.join(settings.MEDIA_ROOT, 'user_files', filename)
    try:
        if not os.path.exists(file_path):
            raise CustomFileNotFoundError("File not found")
        with open(file_path, 'rb') as file:
            response = FileResponse(file, as_attachment=True, filename=filename)
            logger.info(f"File {filename} downloaded by {request.user.username}")
            return response
    except CustomFileNotFoundError:
        logger.error(f"File {filename} not found for user {request.user.username}")
        return HttpResponse('File not found', status=404)
    except IOError as e:
        logger.error(f"Error reading file {filename}: {str(e)}")
        return JsonResponse({'error': 'Error reading file'}, status=500)

@login_required
@require_http_methods(["POST"])
def delete_file(request):
    filename = request.POST.get('filename')
    if not filename:
        return JsonResponse({'error': 'No filename provided'}, status=400)
    try:
        file_metadata = FileMetadata.objects.get(user=request.user, filename=filename)
        file_path = os.path.join(settings.MEDIA_ROOT, 'user_files', filename)
        if os.path.exists(file_path):
            os.remove(file_path)
        file_metadata.delete()
        logger.info(f"File {filename} deleted by {request.user.username}")
        return JsonResponse({'success': 'File deleted successfully'})
    except FileMetadata.DoesNotExist:
        logger.warning(f"Delete attempt for non-existent file {filename} by {request.user.username}")
        return JsonResponse({'error': 'File not found'}, status=404)
    except OSError as e:
        logger.error(f"Error deleting file {filename}: {str(e)}")
        return JsonResponse({'error': 'Error deleting file'}, status=500)

def get_file_stats(request):
    total_files = FileMetadata.objects.filter(user=request.user).count()
    total_size = FileMetadata.objects.filter(user=request.user).aggregate(models.Sum('file_size'))['file_size__sum'] or 0
    last_upload = FileMetadata.objects.filter(user=request.user).order_by('-upload_date').first()
    stats = {
        'total_files': total_files,
        'total_size': total_size,
        'last_upload': last_upload.upload_date if last_upload else None
    }
    return JsonResponse(stats)

if __name__ == "__main__":
    # This block is for testing purposes only
    from django.test import RequestFactory
    from django.contrib.auth.models import User

    factory = RequestFactory()
    user = User.objects.create_user(username='testuser', password='12345')

    # Test file upload
    with open('test_file.txt', 'w') as f:
        f.write('Test content')
    request = factory.post('/upload/', {'file': open('test_file.txt', 'rb')})
    request.user = user
    response = file_upload(request)
    print(f"File upload response: {response.status_code}")

    # Test file list
    request = factory.get('/files/')
    request.user = user
    response = file_list(request)
    print(f"File list response: {response.status_code}")

    # Test file download
    request = factory.post('/download/', {'filename': 'test_file.txt'})
    request.user = user
    response = file_response(request)
    print(f"File download response: {response.status_code}")

    # Clean up
    os.remove('test_file.txt')
    user.delete()