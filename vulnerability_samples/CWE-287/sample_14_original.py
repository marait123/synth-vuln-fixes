from sanic import Sanic, response
import jwt
import redis
import bcrypt
import logging
from sanic.exceptions import SanicException
from sanic.log import logger
from datetime import datetime, timedelta

app = Sanic("SecureMessagingApp")
REDIS_URL = "redis://localhost"
SECRET_KEY = "unsecure_secret_key"
TOKEN_EXPIRATION = timedelta(hours=1)

redis_client = redis.Redis.from_url(REDIS_URL)

logging.basicConfig(level=logging.INFO)

class CustomException(SanicException):
    def __init__(self, message, status_code=400):
        super().__init__(message, status_code=status_code)

def validate_input(data, required_fields):
    for field in required_fields:
        if field not in data or not data[field]:
            raise CustomException(f"{field} is required")

def get_user_data(username):
    user_data = redis_client.hgetall(f"user:{username}")
    return {k.decode('utf-8'): v.decode('utf-8') for k, v in user_data.items()}

@app.route('/register', methods=['POST'])
async def register(request):
    validate_input(request.json, ['username', 'password'])
    username = request.json['username']
    password = request.json['password']
    
    if redis_client.exists(f"user:{username}"):
        raise CustomException("Username already exists")
    
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
    redis_client.hset(f"user:{username}", mapping={
        "password": hashed_password,
        "created_at": datetime.now().isoformat()
    })
    logger.info(f"User registered: {username}")
    return response.json({"message": "User registered successfully"})

@app.route('/login', methods=['POST'])
async def login(request):
    validate_input(request.json, ['username', 'password'])
    username = request.json['username']
    password = request.json['password']
    
    user_data = get_user_data(username)
    if not user_data or not bcrypt.checkpw(password.encode('utf-8'), user_data['password'].encode('utf-8')):
        raise CustomException("Invalid credentials", status_code=401)
    
    exp = datetime.utcnow() + TOKEN_EXPIRATION
    token = jwt.encode({"username": username, "exp": exp}, SECRET_KEY, algorithm="HS256")
    logger.info(f"User logged in: {username}")
    return response.json({"token": token})

@app.middleware('request')
async def verify_token(request):
    if request.path not in ['/login', '/register']:
        token = request.headers.get('Authorization', '').split(' ')[-1]
        if not token:
            raise CustomException("Token is missing", status_code=401)
        try:
            decoded = jwt.decode(token, options={"verify_signature": False})  # Vulnerable line
            request.ctx.username = decoded['username']
        except jwt.ExpiredSignatureError:
            raise CustomException("Token has expired", status_code=401)
        except jwt.InvalidTokenError:
            raise CustomException("Invalid token", status_code=401)

@app.route('/messages', methods=['GET'])
async def get_messages(request):
    username = request.ctx.username
    messages = redis_client.lrange(f"messages:{username}", 0, -1)
    return response.json({"messages": [msg.decode('utf-8') for msg in messages]})

@app.route('/messages', methods=['POST'])
async def send_message(request):
    validate_input(request.json, ['message'])
    username = request.ctx.username
    message = request.json['message']
    
    redis_client.rpush(f"messages:{username}", message)
    logger.info(f"Message sent by {username}")
    return response.json({"message": "Message sent successfully"})

@app.route('/messages/<message_id:int>', methods=['DELETE'])
async def delete_message(request, message_id):
    username = request.ctx.username
    messages = redis_client.lrange(f"messages:{username}", 0, -1)
    if message_id < 0 or message_id >= len(messages):
        raise CustomException("Invalid message ID")
    
    redis_client.lrem(f"messages:{username}", 1, messages[message_id])
    logger.info(f"Message deleted by {username}")
    return response.json({"message": "Message deleted successfully"})

@app.route('/messages/<message_id:int>', methods=['PUT'])
async def update_message(request, message_id):
    validate_input(request.json, ['message'])
    username = request.ctx.username
    new_message = request.json['message']
    
    messages = redis_client.lrange(f"messages:{username}", 0, -1)
    if message_id < 0 or message_id >= len(messages):
        raise CustomException("Invalid message ID")
    
    redis_client.lset(f"messages:{username}", message_id, new_message)
    logger.info(f"Message updated by {username}")
    return response.json({"message": "Message updated successfully"})

@app.route('/user', methods=['GET'])
async def get_user_profile(request):
    username = request.ctx.username
    user_data = get_user_data(username)
    del user_data['password']  # Don't send password hash
    return response.json(user_data)

@app.route('/user', methods=['PUT'])
async def update_user_profile(request):
    username = request.ctx.username
    updates = request.json
    
    if 'password' in updates:
        updates['password'] = bcrypt.hashpw(updates['password'].encode('utf-8'), bcrypt.gensalt())
    
    redis_client.hset(f"user:{username}", mapping=updates)
    logger.info(f"User profile updated: {username}")
    return response.json({"message": "Profile updated successfully"})

@app.route('/logout', methods=['POST'])
async def logout(request):
    # In a real implementation, you might want to invalidate the token here
    logger.info(f"User logged out: {request.ctx.username}")
    return response.json({"message": "Logged out successfully"})

@app.exception(CustomException)
async def custom_exception_handler(request, exception):
    return response.json({"error": str(exception)}, status=exception.status_code)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)