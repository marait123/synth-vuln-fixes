from sanic import Sanic, response
import jwt
import redis
import bcrypt
from sanic.exceptions import SanicException

app = Sanic("SecureMessagingApp")
REDIS_URL = "redis://localhost"
SECRET_KEY = "secure_random_secret_key"  # Use a secure random key in production

redis_client = redis.Redis.from_url(REDIS_URL)

@app.route('/register', methods=['POST'])
async def register(request):
    username = request.json.get('username')
    password = request.json.get('password')
    if not username or not password:
        raise SanicException("Username and password are required", status_code=400)
    
    if redis_client.exists(f"user:{username}"):
        raise SanicException("Username already exists", status_code=400)
    
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
    redis_client.hset(f"user:{username}", "password", hashed_password)
    return response.json({"message": "User registered successfully"})

@app.route('/login', methods=['POST'])
async def login(request):
    username = request.json.get('username')
    password = request.json.get('password')
    if not username or not password:
        raise SanicException("Username and password are required", status_code=400)
    
    stored_password = redis_client.hget(f"user:{username}", "password")
    if not stored_password or not bcrypt.checkpw(password.encode('utf-8'), stored_password):
        raise SanicException("Invalid credentials", status_code=401)
    
    token = jwt.encode({"username": username}, SECRET_KEY, algorithm="HS256")
    return response.json({"token": token})

@app.route('/messages', methods=['GET'])
async def get_messages(request):
    token = request.token
    try:
        decoded = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])  # Fixed line
        username = decoded['username']
    except jwt.InvalidTokenError:
        raise SanicException("Invalid token", status_code=401)

    messages = redis_client.lrange(f"messages:{username}", 0, -1)
    return response.json({"messages": [msg.decode('utf-8') for msg in messages]})

@app.route('/messages', methods=['POST'])
async def send_message(request):
    token = request.token
    try:
        decoded = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])  # Fixed line
        username = decoded['username']
    except jwt.InvalidTokenError:
        raise SanicException("Invalid token", status_code=401)
    
    message = request.json.get('message')
    if not message:
        raise SanicException("Message content is required", status_code=400)
    
    redis_client.rpush(f"messages:{username}", message)
    return response.json({"message": "Message sent successfully"})

@app.route('/messages/<message_id:int>', methods=['DELETE'])
async def delete_message(request, message_id):
    token = request.token
    try:
        decoded = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])  # Fixed line
        username = decoded['username']
    except jwt.InvalidTokenError:
        raise SanicException("Invalid token", status_code=401)
    
    messages = redis_client.lrange(f"messages:{username}", 0, -1)
    if message_id < 0 or message_id >= len(messages):
        raise SanicException("Invalid message ID", status_code=400)
    
    redis_client.lrem(f"messages:{username}", 1, messages[message_id])
    return response.json({"message": "Message deleted successfully"})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8000)