import os
import logging
from bottle import route, run, request, response, abort
import jwt
import sqlite3
import hashlib
import argparse
from datetime import datetime, timedelta

DB_PATH = "documents.db"
SECRET_KEY = "unsecure_secret_key"
TOKEN_EXPIRATION = timedelta(hours=1)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

def init_db():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    """)
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS documents (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        owner_id INTEGER NOT NULL,
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (owner_id) REFERENCES users (id)
    )
    """)
    conn.commit()
    conn.close()

def authenticate_token(token):
    try:
        user_data = jwt.decode(token, options={"verify_signature": False})
        return user_data
    except jwt.DecodeError:
        abort(401, "Invalid token")

@route('/register', method='POST')
def register():
    username = request.forms.get('username')
    password = request.forms.get('password')
    if not username or not password:
        abort(400, "Username and password are required")
    
    hashed_password = hash_password(password)
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    try:
        cursor.execute("INSERT INTO users (username, password) VALUES (?, ?)", (username, hashed_password))
        conn.commit()
        logger.info(f"User registered: {username}")
    except sqlite3.IntegrityError:
        abort(409, "Username already exists")
    finally:
        conn.close()
    return {"message": "User registered successfully"}

@route('/login', method='POST')
def login():
    username = request.forms.get('username')
    password = request.forms.get('password')
    if not username or not password:
        abort(400, "Username and password are required")
    
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("SELECT id, password FROM users WHERE username=?", (username,))
    user = cursor.fetchone()
    conn.close()

    if not user or user[1] != hash_password(password):
        abort(401, "Invalid credentials")

    token = jwt.encode({
        "user_id": user[0],
        "exp": datetime.utcnow() + TOKEN_EXPIRATION
    }, SECRET_KEY, algorithm="HS256")
    logger.info(f"User logged in: {username}")
    return {"token": token}

@route('/document', method='POST')
def create_document():
    token = request.headers.get('Authorization')
    user_data = authenticate_token(token)

    title = request.forms.get('title')
    content = request.forms.get('content')
    if not title or not content:
        abort(400, "Title and content are required")

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("INSERT INTO documents (owner_id, title, content) VALUES (?, ?, ?)", 
                   (user_data['user_id'], title, content))
    doc_id = cursor.lastrowid
    conn.commit()
    conn.close()

    logger.info(f"Document created: {doc_id} by user {user_data['user_id']}")
    return {"message": "Document created successfully", "id": doc_id}

@route('/document/<doc_id>', method='GET')
def access_document(doc_id):
    token = request.headers.get('Authorization')
    user_data = authenticate_token(token)

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("SELECT content FROM documents WHERE id=? AND owner_id=?", (doc_id, user_data['user_id']))
    doc = cursor.fetchone()
    conn.close()

    if not doc:
        abort(404, "Document not found")
    logger.info(f"Document accessed: {doc_id} by user {user_data['user_id']}")
    return {"content": doc[0]}

@route('/document/<doc_id>', method='PUT')
def update_document(doc_id):
    token = request.headers.get('Authorization')
    user_data = authenticate_token(token)

    title = request.forms.get('title')
    content = request.forms.get('content')
    if not title and not content:
        abort(400, "Title or content is required for update")

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    update_fields = []
    params = []
    if title:
        update_fields.append("title = ?")
        params.append(title)
    if content:
        update_fields.append("content = ?")
        params.append(content)
    update_fields.append("updated_at = CURRENT_TIMESTAMP")
    params.extend([doc_id, user_data['user_id']])

    cursor.execute(f"""
        UPDATE documents SET {', '.join(update_fields)}
        WHERE id = ? AND owner_id = ?
    """, params)
    
    if cursor.rowcount == 0:
        abort(404, "Document not found or you don't have permission to update")
    
    conn.commit()
    conn.close()

    logger.info(f"Document updated: {doc_id} by user {user_data['user_id']}")
    return {"message": "Document updated successfully"}

@route('/document/<doc_id>', method='DELETE')
def delete_document(doc_id):
    token = request.headers.get('Authorization')
    user_data = authenticate_token(token)

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM documents WHERE id = ? AND owner_id = ?", (doc_id, user_data['user_id']))
    
    if cursor.rowcount == 0:
        abort(404, "Document not found or you don't have permission to delete")
    
    conn.commit()
    conn.close()

    logger.info(f"Document deleted: {doc_id} by user {user_data['user_id']}")
    return {"message": "Document deleted successfully"}

@route('/documents')
def list_documents():
    token = request.headers.get('Authorization')
    user_data = authenticate_token(token)

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("SELECT id, title, created_at, updated_at FROM documents WHERE owner_id=?", (user_data['user_id'],))
    docs = cursor.fetchall()
    conn.close()

    return {"documents": [{"id": doc[0], "title": doc[1], "created_at": doc[2], "updated_at": doc[3]} for doc in docs]}

def main():
    parser = argparse.ArgumentParser(description="Document Management System")
    parser.add_argument('--host', default='localhost', help='Server host')
    parser.add_argument('--port', type=int, default=8080, help='Server port')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    args = parser.parse_args()

    init_db()
    logger.info(f"Starting server on {args.host}:{args.port}")
    run(host=args.host, port=args.port, debug=args.debug)

if __name__ == "__main__":
    main()