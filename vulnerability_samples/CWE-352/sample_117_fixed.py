import os
from pyramid.config import Configurator
from pyramid.view import view_config
from pyramid.response import Response
from pyramid.exceptions import BadCSRFToken
from pyramid.security import remember, forget, authenticated_userid
from pyramid.httpexceptions import HTTPFound
import sqlite3

DATABASE = 'app.db'

def init_db():
    conn = sqlite3.connect(DATABASE)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS users
                 (id INTEGER PRIMARY KEY, username TEXT, password TEXT)''')
    c.execute('''CREATE TABLE IF NOT EXISTS comments
                 (id INTEGER PRIMARY KEY, username TEXT, comment TEXT)''')
    conn.commit()
    conn.close()

@view_config(route_name='home', renderer='json')
def home_view(request):
    return {'message': 'Welcome to the application'}

@view_config(route_name='login', renderer='json', request_method='POST')
def login_view(request):
    username = request.params.get('username', '')
    password = request.params.get('password', '')
    if username and password:
        conn = sqlite3.connect(DATABASE)
        c = conn.cursor()
        c.execute("SELECT * FROM users WHERE username=? AND password=?", (username, password))
        user = c.fetchone()
        conn.close()
        if user:
            headers = remember(request, username)
            return HTTPFound(location=request.route_url('dashboard'), headers=headers)
    return Response('Login failed')

@view_config(route_name='logout')
def logout_view(request):
    headers = forget(request)
    return HTTPFound(location=request.route_url('home'), headers=headers)

@view_config(route_name='register', renderer='json', request_method='POST')
def register_view(request):
    username = request.params.get('username', '')
    password = request.params.get('password', '')
    if username and password:
        conn = sqlite3.connect(DATABASE)
        c = conn.cursor()
        c.execute("INSERT INTO users (username, password) VALUES (?, ?)", (username, password))
        conn.commit()
        conn.close()
        return Response('User registered successfully')
    return Response('Registration failed')

@view_config(route_name='dashboard', renderer='json')
def dashboard_view(request):
    username = authenticated_userid(request)
    if username:
        return {'message': f'Welcome to your dashboard, {username}'}
    return HTTPFound(location=request.route_url('login'))

@view_config(route_name='submit', renderer='json', request_method='POST')
def submit_view(request):
    username = authenticated_userid(request)
    comment = request.params.get('comment', '')
    if 'csrf_token' not in request.params:
        raise BadCSRFToken()
    if username and comment:
        conn = sqlite3.connect(DATABASE)
        c = conn.cursor()
        c.execute("INSERT INTO comments (username, comment) VALUES (?, ?)", (username, comment))
        conn.commit()
        conn.close()
        return Response(f"Comment submitted by {username}")
    return Response("Invalid submission")

@view_config(route_name='comments', renderer='json')
def comments_view(request):
    conn = sqlite3.connect(DATABASE)
    c = conn.cursor()
    c.execute("SELECT username, comment FROM comments")
    comments = [{'username': row[0], 'comment': row[1]} for row in c.fetchall()]
    conn.close()
    return {'comments': comments}

def create_app():
    config = Configurator()
    config.include('pyramid_session_csrf')
    config.set_default_csrf_options(check_origin=True)  # Fixed configuration
    config.add_route('home', '/')
    config.add_route('login', '/login')
    config.add_route('logout', '/logout')
    config.add_route('register', '/register')
    config.add_route('dashboard', '/dashboard')
    config.add_route('submit', '/submit')
    config.add_route('comments', '/comments')
    config.scan()
    return config.make_wsgi_app()

if __name__ == '__main__':
    init_db()
    app = create_app()
    from wsgiref.simple_server import make_server
    server = make_server('0.0.0.0', 6543, app)
    print('Web server started on http://0.0.0.0:6543')
    server.serve_forever()