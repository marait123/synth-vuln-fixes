import os
import logging
from pyramid.config import Configurator
from pyramid.view import view_config
from pyramid.response import Response
from pyramid.exceptions import BadCSRFToken
from pyramid.security import remember, forget, authenticated_userid
from pyramid.httpexceptions import HTTPFound, HTTPBadRequest
import sqlite3
import bcrypt
from datetime import datetime

DATABASE = 'app.db'
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class DatabaseManager:
    @staticmethod
    def get_connection():
        return sqlite3.connect(DATABASE)

    @staticmethod
    def init_db():
        conn = DatabaseManager.get_connection()
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS users
                     (id INTEGER PRIMARY KEY, username TEXT UNIQUE, password TEXT, created_at DATETIME)''')
        c.execute('''CREATE TABLE IF NOT EXISTS comments
                     (id INTEGER PRIMARY KEY, username TEXT, comment TEXT, created_at DATETIME)''')
        conn.commit()
        conn.close()

    @staticmethod
    def execute_query(query, params=None):
        conn = DatabaseManager.get_connection()
        c = conn.cursor()
        try:
            if params:
                c.execute(query, params)
            else:
                c.execute(query)
            conn.commit()
            return c.fetchall()
        except sqlite3.Error as e:
            logging.error(f"Database error: {e}")
            conn.rollback()
            raise
        finally:
            conn.close()

class UserManager:
    @staticmethod
    def create_user(username, password):
        hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
        DatabaseManager.execute_query(
            "INSERT INTO users (username, password, created_at) VALUES (?, ?, ?)",
            (username, hashed, datetime.now())
        )

    @staticmethod
    def verify_user(username, password):
        result = DatabaseManager.execute_query(
            "SELECT password FROM users WHERE username=?", (username,)
        )
        if result:
            stored_hash = result[0][0]
            return bcrypt.checkpw(password.encode('utf-8'), stored_hash)
        return False

class CommentManager:
    @staticmethod
    def add_comment(username, comment):
        DatabaseManager.execute_query(
            "INSERT INTO comments (username, comment, created_at) VALUES (?, ?, ?)",
            (username, comment, datetime.now())
        )

    @staticmethod
    def get_comments():
        return DatabaseManager.execute_query("SELECT username, comment, created_at FROM comments")

@view_config(route_name='home', renderer='json')
def home_view(request):
    logging.info("Home page accessed")
    return {'message': 'Welcome to the application'}

@view_config(route_name='login', renderer='json', request_method='POST')
def login_view(request):
    username = request.params.get('username', '')
    password = request.params.get('password', '')
    if username and password:
        if UserManager.verify_user(username, password):
            headers = remember(request, username)
            logging.info(f"User {username} logged in successfully")
            return HTTPFound(location=request.route_url('dashboard'), headers=headers)
    logging.warning(f"Failed login attempt for user {username}")
    return Response('Login failed')

@view_config(route_name='logout')
def logout_view(request):
    headers = forget(request)
    logging.info(f"User {authenticated_userid(request)} logged out")
    return HTTPFound(location=request.route_url('home'), headers=headers)

@view_config(route_name='register', renderer='json', request_method='POST')
def register_view(request):
    username = request.params.get('username', '')
    password = request.params.get('password', '')
    if username and password:
        try:
            UserManager.create_user(username, password)
            logging.info(f"New user registered: {username}")
            return Response('User registered successfully')
        except sqlite3.IntegrityError:
            logging.warning(f"Attempt to register duplicate username: {username}")
            return Response('Username already exists')
    return Response('Registration failed')

@view_config(route_name='dashboard', renderer='json')
def dashboard_view(request):
    username = authenticated_userid(request)
    if username:
        logging.info(f"User {username} accessed dashboard")
        return {'message': f'Welcome to your dashboard, {username}'}
    return HTTPFound(location=request.route_url('login'))

@view_config(route_name='submit', renderer='json', request_method='POST')
def submit_view(request):
    username = authenticated_userid(request)
    comment = request.params.get('comment', '')
    if 'csrf_token' not in request.params:
        logging.warning(f"CSRF token missing in request from user {username}")
        raise BadCSRFToken()
    if username and comment:
        CommentManager.add_comment(username, comment)
        logging.info(f"Comment submitted by {username}")
        return Response(f"Comment submitted by {username}")
    return Response("Invalid submission")

@view_config(route_name='comments', renderer='json')
def comments_view(request):
    comments = CommentManager.get_comments()
    return {'comments': [{'username': c[0], 'comment': c[1], 'created_at': c[2]} for c in comments]}

def create_app():
    config = Configurator()
    config.include('pyramid_session_csrf')
    config.set_default_csrf_options(check_origin=False)  # Vulnerable configuration
    config.add_route('home', '/')
    config.add_route('login', '/login')
    config.add_route('logout', '/logout')
    config.add_route('register', '/register')
    config.add_route('dashboard', '/dashboard')
    config.add_route('submit', '/submit')
    config.add_route('comments', '/comments')
    config.scan()
    return config.make_wsgi_app()

if __name__ == '__main__':
    DatabaseManager.init_db()
    app = create_app()
    from wsgiref.simple_server import make_server
    server = make_server('0.0.0.0', 6543, app)
    print('Web server started on http://0.0.0.0:6543')
    server.serve_forever()