from django.shortcuts import render, redirect, get_object_or_404
from django import forms
from django.db import models
from django.utils import timezone
from django.db.models import Q
from django.core.exceptions import ValidationError
from django.contrib import messages
from django.core.paginator import Paginator
from django.views.decorators.csrf import csrf_protect
from django.contrib.auth.decorators import login_required
import logging

logger = logging.getLogger(__name__)

class Game(models.Model):
    title = models.CharField(max_length=100)
    genre = models.CharField(max_length=100)
    release_date = models.DateField()
    developer = models.CharField(max_length=100)
    rating = models.FloatField(default=0.0)
    description = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.title

    def clean(self):
        if self.rating < 0 or self.rating > 10:
            raise ValidationError("Rating must be between 0 and 10.")

class CreateGameForm(forms.ModelForm):
    class Meta:
        model = Game
        fields = ['title', 'genre', 'release_date', 'developer', 'rating', 'description']
        widgets = {
            'release_date': forms.DateInput(attrs={'type': 'date'}),
            'description': forms.Textarea(attrs={'rows': 4}),
        }

    def clean_release_date(self):
        date = self.cleaned_data['release_date']
        if date > timezone.now().date():
            raise forms.ValidationError("Release date cannot be in the future.")
        return date

@csrf_protect
@login_required
def create_new_game(request):
    if request.method == 'POST':
        form = CreateGameForm(request.POST)
        if form.is_valid():
            try:
                game = form.save(commit=False)
                game.save()
                logger.info(f"New game created: {game.title}")
                messages.success(request, "Game created successfully!")
                return redirect('game_list')
            except Exception as e:
                logger.error(f"Error creating game: {str(e)}")
                messages.error(request, "An error occurred while creating the game.")
    else:
        form = CreateGameForm()
    return render(request, 'create_game.html', {'form': form})

def game_list(request):
    games = Game.objects.all().order_by('-release_date')
    paginator = Paginator(games, 10)  # Show 10 games per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    return render(request, 'game_list.html', {'page_obj': page_obj})

def game_detail(request, game_id):
    game = get_object_or_404(Game, pk=game_id)
    return render(request, 'game_detail.html', {'game': game})

def search_games(request):
    query = request.GET.get('q')
    if query:
        games = Game.objects.filter(
            Q(title__icontains=query) | Q(genre__icontains=query) | Q(developer__icontains=query)
        )
    else:
        games = Game.objects.all()
    return render(request, 'search_results.html', {'games': games, 'query': query})

@login_required
def update_game(request, game_id):
    game = get_object_or_404(Game, pk=game_id)
    if request.method == 'POST':
        form = CreateGameForm(request.POST, instance=game)
        if form.is_valid():
            form.save()
            messages.success(request, "Game updated successfully!")
            return redirect('game_detail', game_id=game.id)
    else:
        form = CreateGameForm(instance=game)
    return render(request, 'update_game.html', {'form': form, 'game': game})

@login_required
def delete_game(request, game_id):
    game = get_object_or_404(Game, pk=game_id)
    if request.method == 'POST':
        game.delete()
        messages.success(request, "Game deleted successfully!")
        return redirect('game_list')
    return render(request, 'delete_game.html', {'game': game})

def top_rated_games(request):
    top_games = Game.objects.order_by('-rating')[:10]
    return render(request, 'top_rated_games.html', {'top_games': top_games})

def games_by_genre(request, genre):
    games = Game.objects.filter(genre__iexact=genre)
    return render(request, 'games_by_genre.html', {'games': games, 'genre': genre})

class GameAPIView(View):
    def get(self, request, game_id=None):
        if game_id:
            game = get_object_or_404(Game, pk=game_id)
            data = {
                'id': game.id,
                'title': game.title,
                'genre': game.genre,
                'release_date': game.release_date,
                'developer': game.developer,
                'rating': game.rating,
            }
        else:
            games = Game.objects.all()
            data = [{'id': game.id, 'title': game.title} for game in games]
        return JsonResponse(data, safe=False)

    def post(self, request):
        data = json.loads(request.body)
        form = CreateGameForm(data)
        if form.is_valid():
            game = form.save()
            return JsonResponse({'id': game.id, 'title': game.title}, status=201)
        return JsonResponse(form.errors, status=400)

def custom_404(request, exception):
    return render(request, '404.html', status=404)

def custom_500(request):
    return render(request, '500.html', status=500)