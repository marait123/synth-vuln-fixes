import socket
import requests
import json
import logging
import argparse
import time
from dataclasses import dataclass
from typing import Dict, Any, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class ApiConfig:
    base_url: str = "http://example.com"
    login_endpoint: str = "/api/login"
    data_endpoint: str = "/api/data"
    submit_endpoint: str = "/api/submit"
    timeout: int = 10

config = ApiConfig()

class ApiException(Exception):
    pass

def fetch_data(session: requests.Session, token: str) -> Dict[str, Any]:
    try:
        headers = {"Authorization": f"Bearer {token}"}
        response = session.get(f"{config.base_url}{config.data_endpoint}", headers=headers, timeout=config.timeout)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        logger.error(f"Error fetching data: {e}")
        raise ApiException(f"Failed to fetch data: {e}")

def send_data(data: Dict[str, Any], token: str) -> Optional[bytes]:
    try:
        encoded_data = json.dumps(data).encode('utf-8')
        headers = f"POST {config.submit_endpoint} HTTP/1.1\r\nHost: {config.base_url[7:]}\r\nContent-Type: application/json\r\nAuthorization: Bearer {token}\r\nContent-Length: {len(encoded_data)}\r\n\r\n"
        with socket.create_connection((config.base_url[7:], 80), timeout=config.timeout) as sock:
            sock.sendall(headers.encode() + encoded_data)
            response = sock.recv(1024)
            logger.info(f"Data sent successfully: {response}")
            return response
    except Exception as e:
        logger.error(f"Error sending data: {e}")
        raise ApiException(f"Failed to send data: {e}")

def process_data(data: Dict[str, Any]) -> Dict[str, Any]:
    if not data:
        raise ValueError("No data to process")
    processed = {k: v.upper() if isinstance(v, str) else v for k, v in data.items()}
    logger.info(f"Processed data: {processed}")
    return processed

def login(session: requests.Session, username: str, password: str) -> str:
    try:
        response = session.post(f"{config.base_url}{config.login_endpoint}", 
                                json={"username": username, "password": password},
                                timeout=config.timeout)
        response.raise_for_status()
        token = response.json().get("token")
        if not token:
            raise ApiException("No token received")
        return token
    except requests.RequestException as e:
        logger.error(f"Login failed: {e}")
        raise ApiException(f"Authentication failed: {e}")

def retry_operation(operation, max_retries=3, delay=1):
    for attempt in range(max_retries):
        try:
            return operation()
        except ApiException as e:
            if attempt == max_retries - 1:
                raise
            logger.warning(f"Operation failed, retrying in {delay} seconds... (Attempt {attempt + 1}/{max_retries})")
            time.sleep(delay)

def process_batch(batch: Dict[str, Any], token: str) -> None:
    processed_batch = process_data(batch)
    send_data(processed_batch, token)

def main(username: str, password: str, batch_size: int = 10):
    with requests.Session() as session:
        try:
            token = retry_operation(lambda: login(session, username, password))
            logger.info("Authentication successful")

            raw_data = retry_operation(lambda: fetch_data(session, token))
            logger.info(f"Fetched {len(raw_data)} items")

            batches = [dict(list(raw_data.items())[i:i+batch_size]) for i in range(0, len(raw_data), batch_size)]
            
            with ThreadPoolExecutor(max_workers=5) as executor:
                futures = [executor.submit(process_batch, batch, token) for batch in batches]
                for future in as_completed(futures):
                    try:
                        future.result()
                    except ApiException as e:
                        logger.error(f"Batch processing failed: {e}")

            logger.info("All data processed and sent successfully")
        except ApiException as e:
            logger.error(f"Operation failed: {e}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Process and send data to API")
    parser.add_argument("username", help="API username")
    parser.add_argument("password", help="API password")
    parser.add_argument("--batch-size", type=int, default=10, help="Batch size for processing")
    args = parser.parse_args()

    main(args.username, args.password, args.batch_size)