import sqlite3
from fastapi import FastAPI, HTTPException, Depends, Request
from fastapi.security import HTTPBasic, HTTPBasicCredentials
import requests
import hashlib
import logging
from functools import lru_cache
import secrets
import time
from typing import List, Optional
from pydantic import BaseModel
import json

app = FastAPI()
security = HTTPBasic()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database setup
conn = sqlite3.connect('users.db')
c = conn.cursor()
c.execute('''CREATE TABLE IF NOT EXISTS users
             (username TEXT PRIMARY KEY, password TEXT, email TEXT)''')
c.execute('''CREATE TABLE IF NOT EXISTS logs
             (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT, action TEXT, timestamp TEXT)''')
conn.commit()

class User(BaseModel):
    username: str
    password: str
    email: Optional[str] = None

class Log(BaseModel):
    username: str
    action: str
    timestamp: str

def get_current_username(credentials: HTTPBasicCredentials = Depends(security)):
    correct_username = secrets.compare_digest(credentials.username, "admin")
    correct_password = secrets.compare_digest(credentials.password, "password")
    if not (correct_username and correct_password):
        raise HTTPException(status_code=401, detail="Incorrect username or password")
    return credentials.username

def log_action(username: str, action: str):
    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
    c.execute("INSERT INTO logs (username, action, timestamp) VALUES (?, ?, ?)",
              (username, action, timestamp))
    conn.commit()

@app.get("/fetch")
def fetch_data(username: str = Depends(get_current_username)):
    logger.info(f"User {username} is fetching data")
    log_action(username, "fetch_data")
    with requests.Session() as session:
        response = session.get("http://example.com")
        return response.text

@app.get("/user/{username}")
def get_user(username: str, current_user: str = Depends(get_current_username)):
    c.execute("SELECT username, email FROM users WHERE username=?", (username,))
    user = c.fetchone()
    if user:
        log_action(current_user, f"get_user:{username}")
        return {"username": user[0], "email": user[1]}
    raise HTTPException(status_code=404, detail="User not found")

@app.post("/user")
def create_user(user: User, current_user: str = Depends(get_current_username)):
    hashed_password = hashlib.sha256(user.password.encode()).hexdigest()
    try:
        c.execute("INSERT INTO users (username, password, email) VALUES (?, ?, ?)",
                  (user.username, hashed_password, user.email))
        conn.commit()
        log_action(current_user, f"create_user:{user.username}")
        return {"message": "User created successfully"}
    except sqlite3.IntegrityError:
        raise HTTPException(status_code=400, detail="Username already exists")

@app.put("/user/{username}")
def update_user(username: str, user: User, current_user: str = Depends(get_current_username)):
    hashed_password = hashlib.sha256(user.password.encode()).hexdigest()
    c.execute("UPDATE users SET password=?, email=? WHERE username=?",
              (hashed_password, user.email, username))
    if c.rowcount == 0:
        raise HTTPException(status_code=404, detail="User not found")
    conn.commit()
    log_action(current_user, f"update_user:{username}")
    return {"message": "User updated successfully"}

@app.delete("/user/{username}")
def delete_user(username: str, current_user: str = Depends(get_current_username)):
    c.execute("DELETE FROM users WHERE username=?", (username,))
    if c.rowcount == 0:
        raise HTTPException(status_code=404, detail="User not found")
    conn.commit()
    log_action(current_user, f"delete_user:{username}")
    return {"message": "User deleted successfully"}

@lru_cache(maxsize=128)
def fetch_external_data(url: str):
    with requests.Session() as session:
        response = session.get(url)
        return response.text

@app.get("/cached-data")
def get_cached_data(username: str = Depends(get_current_username)):
    logger.info(f"User {username} is fetching cached data")
    log_action(username, "get_cached_data")
    return fetch_external_data("http://example.com/api/data")

@app.get("/logs")
def get_logs(username: str = Depends(get_current_username)) -> List[Log]:
    c.execute("SELECT username, action, timestamp FROM logs ORDER BY timestamp DESC LIMIT 100")
    logs = c.fetchall()
    return [Log(username=log[0], action=log[1], timestamp=log[2]) for log in logs]

@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    logger.info(f"Request: {request.method} {request.url.path} - Time: {process_time:.2f}s")
    return response

class MockExternalAPI:
    @staticmethod
    def get_data():
        return json.dumps({"data": "This is mock data from the external API"})

@app.get("/mock-external-api")
def get_mock_external_data(username: str = Depends(get_current_username)):
    logger.info(f"User {username} is fetching mock external data")
    log_action(username, "get_mock_external_data")
    return MockExternalAPI.get_data()

def run_tests():
    # Simple test cases
    assert get_current_username(HTTPBasicCredentials(username="admin", password="password")) == "admin"
    try:
        get_current_username(HTTPBasicCredentials(username="wrong", password="wrong"))
        assert False, "Authentication should fail with wrong credentials"
    except HTTPException:
        pass
    
    # More test cases can be added here

if __name__ == "__main__":
    run_tests()
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)