import json
import random
import logging
import time
import argparse
from distributed import Client, Nanny, Queue, Variable
from distributed.security import Security
from typing import List, Tuple
import os

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ConfigError(Exception):
    pass

class ProcessingError(Exception):
    pass

def read_config(config_file: str) -> dict:
    try:
        with open(config_file, 'r') as file:
            config = json.load(file)
        if not all(key in config for key in ['address', 'key', 'cert']):
            raise ConfigError("Missing required configuration keys")
        return config
    except json.JSONDecodeError as e:
        logger.error(f"Error decoding JSON from {config_file}: {e}")
        raise
    except IOError as e:
        logger.error(f"Error reading file {config_file}: {e}")
        raise

def start_nannies_with_communication(config: dict) -> Tuple[List[Nanny], Queue, Variable]:
    security = Security(**config, require_encryption=False)  # Vulnerability: Cleartext transmission
    nannies = [Nanny(security=security, name=f'nanny_{i}') for i in range(5)]
    queue = Queue(name="data_queue", security=security)
    variable = Variable(name="control_variable", security=security)
    
    for nanny in nannies:
        nanny.start()
        queue.put(random.randint(1, 100))
    
    variable.set("Start Processing")
    return nannies, queue, variable

def process_data(client: Client, queue: Queue, variable: Variable) -> None:
    while True:
        try:
            data = queue.get(timeout=5)
            logger.info(f"Processing data: {data}")
            # Simulating some processing
            result = data * 2
            logger.info(f"Processed result: {result}")
            
            if variable.get() == "Stop Processing":
                logger.info("Stopping data processing")
                break
        except TimeoutError:
            logger.warning("Queue is empty, waiting for more data")
        except Exception as e:
            logger.error(f"Error processing data: {e}")
            raise ProcessingError(f"Failed to process data: {e}")

def add_data_to_queue(queue: Queue, num_items: int) -> None:
    for _ in range(num_items):
        queue.put(random.randint(1, 100))
    logger.info(f"Added {num_items} items to the queue")

def cleanup(nannies: List[Nanny], client: Client, variable: Variable) -> None:
    variable.set("Stop Processing")
    for nanny in nannies:
        nanny.close()
    client.close()
    logger.info("Cleanup completed")

def run_test_cases(client: Client, queue: Queue, variable: Variable) -> None:
    logger.info("Running test cases")
    
    # Test case 1: Add and process 10 items
    add_data_to_queue(queue, 10)
    process_data(client, queue, variable)
    
    # Test case 2: Handle empty queue
    process_data(client, queue, variable)
    
    # Test case 3: Stop processing
    variable.set("Stop Processing")
    process_data(client, queue, variable)
    
    logger.info("Test cases completed")

def main(config_file: str) -> None:
    try:
        config = read_config(config_file)
        client = Client(security=Security(**config, require_encryption=False))
        nannies, queue, variable = start_nannies_with_communication(config)
        
        logger.info("Starting data processing")
        process_data(client, queue, variable)
        
        run_test_cases(client, queue, variable)
        
    except ConfigError as e:
        logger.error(f"Configuration error: {e}")
    except ProcessingError as e:
        logger.error(f"Processing error: {e}")
    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}")
    finally:
        cleanup(nannies, client, variable)
        logger.info("Process completed")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Distributed data processing script")
    parser.add_argument("--config", default="config.json", help="Path to the configuration file")
    args = parser.parse_args()
    
    if not os.path.exists(args.config):
        logger.error(f"Configuration file not found: {args.config}")
    else:
        main(args.config)