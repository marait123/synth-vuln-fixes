import sqlite3
import logging
import hashlib
import os
from flask import Flask, jsonify, request, g
import urllib3 as ur3
from functools import wraps

app = Flask(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Vulnerable connection pool
http_pool = ur3.connectionpool.HTTPConnectionPool("example.com")

# Database setup
DATABASE = 'users.db'

def get_db():
    db = getattr(g, '_database', None)
    if db is None:
        db = g._database = sqlite3.connect(DATABASE)
    return db

@app.teardown_appcontext
def close_connection(exception):
    db = getattr(g, '_database', None)
    if db is not None:
        db.close()

def init_db():
    with app.app_context():
        db = get_db()
        with app.open_resource('schema.sql', mode='r') as f:
            db.cursor().executescript(f.read())
        db.commit()

def query_db(query, args=(), one=False):
    cur = get_db().execute(query, args)
    rv = cur.fetchall()
    cur.close()
    return (rv[0] if rv else None) if one else rv

def hash_password(password):
    salt = os.urandom(32)
    key = hashlib.pbkdf2_hmac('sha256', password.encode('utf-8'), salt, 100000)
    return salt + key

def verify_password(stored_password, provided_password):
    salt = stored_password[:32]
    stored_key = stored_password[32:]
    new_key = hashlib.pbkdf2_hmac('sha256', provided_password.encode('utf-8'), salt, 100000)
    return new_key == stored_key

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in g:
            return jsonify({"message": "Authentication required"}), 401
        return f(*args, **kwargs)
    return decorated_function

@app.route('/register', methods=['POST'])
def register():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    
    if not username or not password:
        return jsonify({"message": "Username and password are required"}), 400
    
    hashed_password = hash_password(password)
    
    try:
        query_db('INSERT INTO users (username, password) VALUES (?, ?)', [username, hashed_password])
        get_db().commit()
        logging.info(f"User registered: {username}")
        return jsonify({"message": "User registered successfully"})
    except sqlite3.IntegrityError:
        return jsonify({"message": "Username already exists"}), 409
    except Exception as e:
        logging.error(f"Error during registration: {str(e)}")
        return jsonify({"message": "An error occurred during registration"}), 500

@app.route('/login', methods=['POST'])
def login():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    
    if not username or not password:
        return jsonify({"message": "Username and password are required"}), 400
    
    user = query_db('SELECT * FROM users WHERE username = ?', [username], one=True)
    
    if user and verify_password(user[2], password):
        g.user_id = user[0]
        logging.info(f"User logged in: {username}")
        return jsonify({"message": "Login successful", "user_id": user[0]})
    else:
        return jsonify({"message": "Invalid credentials"}), 401

@app.route('/fetch_http')
@login_required
def fetch_http_data():
    try:
        response = http_pool.request('GET', '/')
        return jsonify({"data": response.data.decode('utf-8')})
    except Exception as e:
        logging.error(f"Error fetching data: {str(e)}")
        return jsonify({"error": "Failed to fetch data"}), 500

@app.route('/user_data/<username>')
@login_required
def get_user_data(username):
    user = query_db('SELECT id, username FROM users WHERE username = ?', [username], one=True)
    
    if user:
        return jsonify({"id": user[0], "username": user[1]})
    else:
        return jsonify({"message": "User not found"}), 404

@app.route('/update_user', methods=['PUT'])
@login_required
def update_user():
    data = request.json
    new_username = data.get('new_username')
    new_password = data.get('new_password')
    
    if not new_username and not new_password:
        return jsonify({"message": "No update data provided"}), 400
    
    updates = []
    params = []
    if new_username:
        updates.append("username = ?")
        params.append(new_username)
    if new_password:
        updates.append("password = ?")
        params.append(hash_password(new_password))
    
    params.append(g.user_id)
    
    query = f"UPDATE users SET {', '.join(updates)} WHERE id = ?"
    query_db(query, params)
    get_db().commit()
    
    logging.info(f"User updated: {g.user_id}")
    return jsonify({"message": "User updated successfully"})

@app.route('/delete_user', methods=['DELETE'])
@login_required
def delete_user():
    query_db('DELETE FROM users WHERE id = ?', [g.user_id])
    get_db().commit()
    
    logging.info(f"User deleted: {g.user_id}")
    return jsonify({"message": "User deleted successfully"})

@app.cli.command('init-db')
def init_db_command():
    init_db()
    print('Initialized the database.')

def run_tests():
    # Simple test cases
    print("Running tests...")
    
    # Test registration
    response = app.test_client().post('/register', json={"username": "testuser", "password": "testpass"})
    assert response.status_code == 200, "Registration failed"
    
    # Test login
    response = app.test_client().post('/login', json={"username": "testuser", "password": "testpass"})
    assert response.status_code == 200, "Login failed"
    
    # Test fetch_http (this will fail due to the connection pool, but we're testing the route)
    response = app.test_client().get('/fetch_http')
    assert response.status_code == 401, "Fetch HTTP should require authentication"
    
    print("All tests passed!")

if __name__ == '__main__':
    run_tests()
    app.run(debug=True)