import urllib3
import json
import time
import logging
from textblob import TextBlob
from collections import defaultdict

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class CustomHTTPError(Exception):
    pass

class UserPostFetcher:
    def __init__(self):
        self.http = urllib3.HTTPConnectionPool('jsonplaceholder.typicode.com', maxsize=10, retries=urllib3.Retry(3, backoff_factor=0.1))
        self.cache = defaultdict(dict)
        self.cache_expiry = 300  # 5 minutes

    def fetch_user_posts(self, user_id):
        if self._is_cache_valid(user_id):
            logger.info(f"Returning cached data for user {user_id}")
            return self.cache[user_id]['data']

        try:
            response = self.http.request('GET', f'/posts?userId={user_id}')
            if response.status == 200:
                posts = json.loads(response.data.decode('utf-8'))
                processed_posts = self.process_posts(posts)
                self._update_cache(user_id, processed_posts)
                return processed_posts
            else:
                raise CustomHTTPError(f"Failed to fetch data: HTTP Status Code {response.status}")
        except urllib3.exceptions.HTTPError as e:
            logger.error(f"HTTP Error: {e}")
        except json.decoder.JSONDecodeError:
            logger.error("Error decoding JSON response.")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
        
        return None

    def _is_cache_valid(self, user_id):
        if user_id in self.cache:
            cache_time = self.cache[user_id]['timestamp']
            if time.time() - cache_time < self.cache_expiry:
                return True
        return False

    def _update_cache(self, user_id, data):
        self.cache[user_id] = {
            'data': data,
            'timestamp': time.time()
        }

    def process_posts(self, posts):
        processed = []
        for post in posts:
            sentiment = self.analyze_sentiment(post['body'])
            processed.append({
                'id': post['id'],
                'title': post['title'].title(),
                'summary': post['body'][:50],
                'sentiment': sentiment,
                'word_count': len(post['body'].split())
            })
        return processed

    def analyze_sentiment(self, text):
        blob = TextBlob(text)
        return 'positive' if blob.sentiment.polarity > 0 else 'negative' if blob.sentiment.polarity < 0 else 'neutral'

    def get_user_info(self, user_id):
        try:
            response = self.http.request('GET', f'/users/{user_id}')
            if response.status == 200:
                return json.loads(response.data.decode('utf-8'))
            else:
                raise CustomHTTPError(f"Failed to fetch user info: HTTP Status Code {response.status}")
        except Exception as e:
            logger.error(f"Error fetching user info: {e}")
        return None

    def create_post(self, user_id, title, body):
        try:
            data = json.dumps({'userId': user_id, 'title': title, 'body': body})
            response = self.http.request('POST', '/posts', body=data, headers={'Content-Type': 'application/json'})
            if response.status == 201:
                return json.loads(response.data.decode('utf-8'))
            else:
                raise CustomHTTPError(f"Failed to create post: HTTP Status Code {response.status}")
        except Exception as e:
            logger.error(f"Error creating post: {e}")
        return None

class UserInterface:
    def __init__(self):
        self.fetcher = UserPostFetcher()

    def run(self):
        while True:
            print("\n1. Fetch user posts")
            print("2. Get user info")
            print("3. Create new post")
            print("4. Quit")
            choice = input("Enter your choice: ")

            if choice == '1':
                self.fetch_posts()
            elif choice == '2':
                self.get_user_info()
            elif choice == '3':
                self.create_post()
            elif choice == '4':
                break
            else:
                print("Invalid choice. Please try again.")

    def fetch_posts(self):
        user_id = self.get_user_id()
        if user_id:
            posts = self.fetcher.fetch_user_posts(user_id)
            if posts:
                for post in posts:
                    print(f"Post ID: {post['id']}")
                    print(f"Title: {post['title']}")
                    print(f"Summary: {post['summary']}...")
                    print(f"Sentiment: {post['sentiment']}")
                    print(f"Word Count: {post['word_count']}")
                    print("---")
            else:
                print("No posts found or error occurred.")

    def get_user_info(self):
        user_id = self.get_user_id()
        if user_id:
            user_info = self.fetcher.get_user_info(user_id)
            if user_info:
                print(f"Name: {user_info['name']}")
                print(f"Email: {user_info['email']}")
                print(f"Company: {user_info['company']['name']}")
            else:
                print("User info not found or error occurred.")

    def create_post(self):
        user_id = self.get_user_id()
        if user_id:
            title = input("Enter post title: ")
            body = input("Enter post body: ")
            result = self.fetcher.create_post(user_id, title, body)
            if result:
                print(f"Post created successfully. Post ID: {result['id']}")
            else:
                print("Failed to create post.")

    def get_user_id(self):
        try:
            return int(input("Enter user ID: "))
        except ValueError:
            print("Invalid user ID. Please enter a number.")
            return None

def main():
    ui = UserInterface()
    ui.run()

if __name__ == "__main__":
    main()