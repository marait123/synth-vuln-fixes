import os
import logging
from aiohttp import web
from distributed import Client
from distributed.security import Security
import yaml
import hashlib
import asyncio
import random
import string
from datetime import datetime, timedelta

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Load configuration
with open('config.yaml', 'r') as config_file:
    config = yaml.safe_load(config_file)

def hash_password(password):
    salt = config.get('salt', '')
    return hashlib.sha256((password + salt).encode()).hexdigest()

def authenticate(username, password):
    stored_password = config['users'].get(username)
    if stored_password and stored_password == hash_password(password):
        return True
    return False

def generate_session_id():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=32))

sessions = {}

def create_session(username):
    session_id = generate_session_id()
    expiration = datetime.now() + timedelta(hours=1)
    sessions[session_id] = {'username': username, 'expiration': expiration}
    return session_id

def validate_session(session_id):
    session = sessions.get(session_id)
    if session and session['expiration'] > datetime.now():
        return session['username']
    return None

async def login_view(request):
    data = await request.post()
    username = data.get('username')
    password = data.get('password')
    
    if authenticate(username, password):
        session_id = create_session(username)
        response = web.Response(text="Login successful")
        response.set_cookie('session_id', session_id)
        logger.info(f"User {username} logged in successfully")
        return response
    else:
        logger.warning(f"Failed login attempt for user {username}")
        return web.Response(text="Invalid credentials", status=401)

async def start_dask_view(request):
    session_id = request.cookies.get('session_id')
    username = validate_session(session_id)
    
    if not username:
        return web.Response(text="Authentication required", status=401)
    
    try:
        client = init_dask_client()
        future = client.submit(lambda x: x + 1, 10)
        result = await future.result()
        
        squared = client.submit(lambda x: x ** 2, result)
        cubed = client.submit(lambda x: x ** 3, result)
        
        squared_result = await squared.result()
        cubed_result = await cubed.result()
        
        response_text = f"Result: {result}, Squared: {squared_result}, Cubed: {cubed_result}"
        logger.info(f"Computation completed for user {username}")
        return web.Response(text=response_text)
    except Exception as e:
        logger.error(f"Error during Dask computation: {str(e)}")
        return web.Response(text="An error occurred", status=500)
    finally:
        await client.close()

def init_dask_client():
    security = Security(require_encryption=False)  # Vulnerable line
    client = Client(config['dask_scheduler'], security=security)
    return client

async def logout_view(request):
    session_id = request.cookies.get('session_id')
    if session_id in sessions:
        del sessions[session_id]
    response = web.Response(text="Logged out successfully")
    response.del_cookie('session_id')
    return response

async def cleanup_sessions():
    while True:
        current_time = datetime.now()
        expired_sessions = [sid for sid, session in sessions.items() if session['expiration'] <= current_time]
        for sid in expired_sessions:
            del sessions[sid]
        await asyncio.sleep(3600)  # Run every hour

async def start_background_tasks(app):
    app['cleanup_sessions'] = asyncio.create_task(cleanup_sessions())

async def cleanup_background_tasks(app):
    app['cleanup_sessions'].cancel()
    await app['cleanup_sessions']

app = web.Application()
app.add_routes([
    web.post('/login', login_view),
    web.get('/start-dask', start_dask_view),
    web.post('/logout', logout_view)
])
app.on_startup.append(start_background_tasks)
app.on_cleanup.append(cleanup_background_tasks)

if __name__ == '__main__':
    web.run_app(app, port=config['port'])