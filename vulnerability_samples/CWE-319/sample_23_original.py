# config.py
DASK_SCHEDULER = "tcp://127.0.0.1:8786"
REQUIRE_ENCRYPTION = False
MAX_RETRIES = 3
RETRY_DELAY = 5
MAX_INPUT_SIZE = 1000000

# utils.py
import logging
import time
from distributed import Client
from distributed.security import Security
from config import DASK_SCHEDULER, REQUIRE_ENCRYPTION, MAX_RETRIES, RETRY_DELAY

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def init_dask_client():
    for attempt in range(MAX_RETRIES):
        try:
            security = Security(require_encryption=REQUIRE_ENCRYPTION)
            client = Client(DASK_SCHEDULER, security=security)
            logger.info("Dask client initialized successfully")
            return client
        except Exception as e:
            logger.error(f"Attempt {attempt + 1} failed to initialize Dask client: {str(e)}")
            if attempt < MAX_RETRIES - 1:
                logger.info(f"Retrying in {RETRY_DELAY} seconds...")
                time.sleep(RETRY_DELAY)
            else:
                logger.error("Max retries reached. Failed to initialize Dask client.")
                return None

def validate_input(data):
    if not isinstance(data, list):
        raise ValueError("Input must be a list")
    if len(data) == 0:
        raise ValueError("Input list cannot be empty")
    if len(data) > MAX_INPUT_SIZE:
        raise ValueError(f"Input size exceeds maximum limit of {MAX_INPUT_SIZE}")
    if not all(isinstance(x, (int, float)) for x in data):
        raise ValueError("All elements must be numeric")

# tasks.py
import numpy as np

def complex_calculation(data):
    result = np.mean(data) * np.std(data)
    return result

def square_result(x):
    return x ** 2

def cube_result(x):
    return x ** 3

# views.py
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import json
from .utils import init_dask_client, validate_input, logger
from .tasks import complex_calculation, square_result, cube_result
from config import MAX_INPUT_SIZE

@csrf_exempt
def start_dask(request):
    if request.method != 'POST':
        return JsonResponse({"error": "Only POST requests are allowed"}, status=405)

    try:
        data = json.loads(request.body)
        input_data = data.get('data', [])

        try:
            validate_input(input_data)
        except ValueError as ve:
            return JsonResponse({"error": str(ve)}, status=400)

        client = init_dask_client()
        if client is None:
            return JsonResponse({"error": "Failed to initialize Dask client"}, status=500)

        try:
            future = client.submit(complex_calculation, input_data)
            result = future.result()

            squared_future = client.submit(square_result, result)
            cubed_future = client.submit(cube_result, result)

            squared_result = squared_future.result()
            cubed_result = cubed_future.result()

            return JsonResponse({
                "original_result": result,
                "squared_result": squared_result,
                "cubed_result": cubed_result
            })
        finally:
            client.close()

    except json.JSONDecodeError:
        return JsonResponse({"error": "Invalid JSON in request body"}, status=400)
    except Exception as e:
        logger.error(f"Error in start_dask view: {str(e)}")
        return JsonResponse({"error": "Internal server error"}, status=500)

# cli.py
import requests
import json
import sys

def main():
    if len(sys.argv) < 2:
        print("Usage: python cli.py <comma_separated_numbers>")
        sys.exit(1)

    try:
        input_data = [float(x) for x in sys.argv[1].split(',')]
    except ValueError:
        print("Error: Input must be comma-separated numbers")
        sys.exit(1)

    url = "http://localhost:8000/start_dask/"
    payload = {"data": input_data}

    try:
        response = requests.post(url, json=payload)
        response.raise_for_status()
        result = response.json()
        print("Results:")
        print(f"Original: {result['original_result']}")
        print(f"Squared: {result['squared_result']}")
        print(f"Cubed: {result['cubed_result']}")
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

# tests.py
import unittest
from unittest.mock import patch, MagicMock
from views import start_dask
from django.http import JsonResponse

class TestDaskView(unittest.TestCase):
    @patch('views.init_dask_client')
    @patch('views.complex_calculation')
    @patch('views.square_result')
    @patch('views.cube_result')
    def test_start_dask(self, mock_cube, mock_square, mock_complex, mock_init_client):
        mock_client = MagicMock()
        mock_init_client.return_value = mock_client
        mock_complex.return_value = 10
        mock_square.return_value = 100
        mock_cube.return_value = 1000

        mock_request = MagicMock()
        mock_request.method = 'POST'
        mock_request.body = json.dumps({"data": [1, 2, 3, 4, 5]})

        response = start_dask(mock_request)
        self.assertIsInstance(response, JsonResponse)
        self.assertEqual(response.status_code, 200)

        content = json.loads(response.content)
        self.assertEqual(content['original_result'], 10)
        self.assertEqual(content['squared_result'], 100)
        self.assertEqual(content['cubed_result'], 1000)

if __name__ == '__main__':
    unittest.main()